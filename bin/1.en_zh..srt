1
00:00:00,800 --> 00:00:05,210
好吧，让我们开始
all right let's get started

2
00:00:05,210 --> 00:00:11,820
这是682的分布式系统等等
this is 682 for distributed systems so

3
00:00:11,820 --> 00:00:13,230
我想开始只是简单的
I'd like to start with just a brief

4
00:00:13,230 --> 00:00:14,639
什么，我想解释
explanation of what I think a

5
00:00:14,639 --> 00:00:18,960
分布式系统是你知道的核心
distributed system is you know the core

6
00:00:18,960 --> 00:00:21,630
它是一组协作计算机
of it is a set of cooperating computers

7
00:00:21,630 --> 00:00:23,190
被彼此进行通信
that are communicating with each other

8
00:00:23,190 --> 00:00:26,190
网络上得到一些连贯的任务
over networked to get some coherent task

9
00:00:26,190 --> 00:00:29,730
这样网络的各种例子说
done and so the kinds of examples that

10
00:00:29,730 --> 00:00:31,530
我们将重点放在本类中
we'll be focusing on in this class are

11
00:00:31,530 --> 00:00:34,970
之类的东西储存大网站或
things like storage for big websites or

12
00:00:34,970 --> 00:00:38,660
大数据计算诸如MapReduce的
big data computations such as MapReduce

13
00:00:38,660 --> 00:00:41,760
也有些更奇特的东西
and also somewhat more exotic things

14
00:00:41,760 --> 00:00:43,950
像对等网络文件共享等等
like peer-to-peer file sharing so

15
00:00:43,950 --> 00:00:45,870
他们都只是例子种
they're all just examples the kinds of

16
00:00:45,870 --> 00:00:48,329
我们来看看案例研究，在与
case studies we'll look at and the

17
00:00:48,329 --> 00:00:49,800
之所以这样，所有重要的是，
reason why all this is important is that

18
00:00:49,800 --> 00:00:51,600
很多重要的基础设施出
a lot of critical infrastructure out

19
00:00:51,600 --> 00:00:53,489
有内置了分布式
there is built out of distributed

20
00:00:53,489 --> 00:00:56,250
需要系统的基础设施
systems infrastructure that requires

21
00:00:56,250 --> 00:00:57,570
多台电脑，以获取其工作
more than one computer to get its job

22
00:00:57,570 --> 00:00:59,579
完成或这有点内在需要
done or it's sort of inherently needs to

23
00:00:59,579 --> 00:01:04,019
在物理上分散做的理由
be spread out physically so the reasons

24
00:01:04,019 --> 00:01:06,300
人们为什么建立这个东西，所以第一
why people build this stuff so first of

25
00:01:06,300 --> 00:01:08,190
所有我甚至谈论分发前
all before I even talk about distributed

26
00:01:08,190 --> 00:01:10,500
系统之类的提醒你，你知道
systems sort of remind you that you know

27
00:01:10,500 --> 00:01:12,420
如果你正在设计一个系统，重新设计
if you're designing a system redesigning

28
00:01:12,420 --> 00:01:14,280
你需要解决，如果你的一些问题
you need to solve some problem if you

29
00:01:14,280 --> 00:01:16,409
都不可能解决它在一个单一
can possibly solve it on a single

30
00:01:16,409 --> 00:01:18,570
计算机，你知道不建
computer you know without building a

31
00:01:18,570 --> 00:01:20,100
分布式系统，你应该做的是
distributed system you should do it that

32
00:01:20,100 --> 00:01:23,340
方式有很多很多的工作，你可以
way and there's many many jobs you can

33
00:01:23,340 --> 00:01:25,080
获得一台计算机上完成的，它是
get done on a single computer and it's

34
00:01:25,080 --> 00:01:29,220
总是比较容易使分布式系统你
always easier so distributed systems you

35
00:01:29,220 --> 00:01:30,780
知道你应该尝试一切
know you should try everything else

36
00:01:30,780 --> 00:01:32,400
然后再尝试构建分布式
before you try building distributed

37
00:01:32,400 --> 00:01:34,020
系统，因为他们不是他们不
systems because they're not they're not

38
00:01:34,020 --> 00:01:36,630
简单所以人们为什么的原因
simpler so the reason why people are

39
00:01:36,630 --> 00:01:39,060
驱动使用大量的合作
driven to use lots of cooperating

40
00:01:39,060 --> 00:01:41,640
电脑是他们需要得到
computers are they need to get

41
00:01:41,640 --> 00:01:43,350
高性能和思维方式
high-performance and the way to think

42
00:01:43,350 --> 00:01:45,180
关于这就是他们想要得到实现
about that is they want to get achieve

43
00:01:45,180 --> 00:01:50,520
某种并行地段的CPU的
some sort of parallelism lots of CPUs

44
00:01:50,520 --> 00:01:52,409
很多回忆大量的磁盘臂的
lots of memories lots of disk arms

45
00:01:52,409 --> 00:01:56,580
平行移动的另一个原因
moving in parallel another reason why

46
00:01:56,580 --> 00:01:58,290
人们建立这种东西是要能够
people build this stuff is to be able to

47
00:01:58,290 --> 00:02:01,070
容忍故障
tolerate faults

48
00:02:05,310 --> 00:02:07,900
有两台电脑做同样的
have two computers do the exact same

49
00:02:07,900 --> 00:02:09,580
如果事情他们中的一个失败，您可以切
thing if one of them fails you can cut

50
00:02:09,580 --> 00:02:12,610
到另一个另一个原因是，
over to the other one another is that

51
00:02:12,610 --> 00:02:15,070
有些问题只是自然传播
some problems are just naturally spread

52
00:02:15,070 --> 00:02:17,560
在太空中像你知道你想
out in space like you know you want to

53
00:02:17,560 --> 00:02:19,420
做钱跨行转账或
do interbank transfers of money or

54
00:02:19,420 --> 00:02:21,820
东西好，你知道银行有这个
something well you know bank a has this

55
00:02:21,820 --> 00:02:23,980
电脑在纽约市和B银行作为
computer in New York City and Bank B as

56
00:02:23,980 --> 00:02:26,110
这台计算机在伦敦，你知道你
this computer in London you know you

57
00:02:26,110 --> 00:02:27,790
只是有一些办法来为他们
just have to have some way for them to

58
00:02:27,790 --> 00:02:29,709
互相交谈和合作，
talk to each other and cooperate in

59
00:02:29,709 --> 00:02:31,330
为了携带出这么有一些
order to carry that out so there's some

60
00:02:31,330 --> 00:02:36,310
自然排序物理原因系统
natural sort of physical reasons systems

61
00:02:36,310 --> 00:02:37,360
这本质上是物理
that are inherently physically

62
00:02:37,360 --> 00:02:40,000
分布式的最终原因，
distributed for the final reason that

63
00:02:40,000 --> 00:02:42,040
人们建立这个东西是为了
people build this stuff is in order to

64
00:02:42,040 --> 00:02:44,320
实现某种形式的安全目标，使
achieve some sort of security goal so

65
00:02:44,320 --> 00:02:46,660
常常，如果有一些代码，你不
often by if there's some code you don't

66
00:02:46,660 --> 00:02:49,090
信托或你知道你需要互动
trust or you know you need to interact

67
00:02:49,090 --> 00:02:50,920
与某人，但你知道他们可能不
with somebody but you know they may not

68
00:02:50,920 --> 00:02:53,170
是即时的恶意或者也许他们
be immediate malicious or maybe their

69
00:02:53,170 --> 00:02:55,420
代码中有错误，所以你不想
code has bugs in it so you don't want to

70
00:02:55,420 --> 00:02:57,160
要相信它，你可能需要分割
have to trust it you may want to split

71
00:02:57,160 --> 00:02:59,350
起来计算，所以你知道你的
up the computation so you know your

72
00:02:59,350 --> 00:03:01,000
东西跑那边那台电脑
stuff runs over there and that computer

73
00:03:01,000 --> 00:03:02,500
我的东西在这里运行在这台计算机上，并
my stuff runs here on this computer and

74
00:03:02,500 --> 00:03:04,150
他们只说给对方一些
they only talk to each other to some

75
00:03:04,150 --> 00:03:06,580
排序窄狭义的网络的
sort of narrow narrowly defined network

76
00:03:06,580 --> 00:03:10,330
协议假设我们可能会担心
protocol assuming we may be worried

77
00:03:10,330 --> 00:03:13,570
你知道的安全，这就是
about you know security and that's

78
00:03:13,570 --> 00:03:14,980
通过拆分东西到实现
achieved by splitting things up into

79
00:03:14,980 --> 00:03:16,420
多台电脑，让他们可以
multiple computers so that they can be

80
00:03:16,420 --> 00:03:21,459
分离出的最这当然是
isolated the most of this course is

81
00:03:21,459 --> 00:03:23,920
将是关于性能和故障
going to be about performance and fault

82
00:03:23,920 --> 00:03:26,410
宽容虽然经常另外两个
tolerance although the other two often

83
00:03:26,410 --> 00:03:28,630
通过那种方式本身工作
work themselves in by way of the sort of

84
00:03:28,630 --> 00:03:30,070
在案例研究的限制
constraints on the case studies that

85
00:03:30,070 --> 00:03:32,799
我们要看看你知道所有
we're going to look at you know all

86
00:03:32,799 --> 00:03:34,390
这些分布式系统，使这些
these distributed systems so these

87
00:03:34,390 --> 00:03:36,430
问题是，因为他们有很多
problems are because they have many

88
00:03:36,430 --> 00:03:39,810
零件和部件并发执行
parts and the parts execute concurrently

89
00:03:39,810 --> 00:03:42,220
因为有多个计算机，您
because there are multiple computers you

90
00:03:42,220 --> 00:03:43,510
得到所有搞出问题
get all the problems that come up with

91
00:03:43,510 --> 00:03:45,190
并发编程的所有排序
concurrent programming all the sort of

92
00:03:45,190 --> 00:03:46,720
复杂的相互作用和我们
complex interactions and we're

93
00:03:46,720 --> 00:03:49,660
时间相关的东西，这就是部分
timing-dependent stuff and that's part

94
00:03:49,660 --> 00:03:51,780
是什么使分布式系统硬
of what makes distributed systems hard

95
00:03:51,780 --> 00:03:54,340
这使得分布式另一件事
another thing that makes distributed

96
00:03:54,340 --> 00:03:56,920
系统硬盘是因为你再次
systems hard is that because again you

97
00:03:56,920 --> 00:03:59,410
拥有多条加一个网络，你
have multiple pieces plus a network you

98
00:03:59,410 --> 00:04:02,440
可以有很意外故障
can have very unexpected failure

99
00:04:02,440 --> 00:04:04,540
模式，就是如果你有一个
patterns that is if you have a single

100
00:04:04,540 --> 00:04:06,280
计算机它通常是两种情况
computer it's usually the case either

101
00:04:06,280 --> 00:04:08,350
计算机工程或可能崩溃或
computer works or maybe it crashes or

102
00:04:08,350 --> 00:04:11,050
遭受停电或东西，但
suffers a power failure or something but

103
00:04:11,050 --> 00:04:12,280
它几乎无论是工作还是不
it pretty much either works or doesn't

104
00:04:12,280 --> 00:04:14,470
大量的由工作分布式系统
work distributed systems made up of lots

105
00:04:14,470 --> 00:04:15,940
电脑，你可以有偏
of computers you can have partial

106
00:04:15,940 --> 00:04:18,399
失败是一些停止件
failures that is some pieces stopped

107
00:04:18,399 --> 00:04:20,140
工作的其他人的其他作品
working other people other pieces

108
00:04:20,140 --> 00:04:22,450
继续工作或者也许是电脑
continue working or maybe the computers

109
00:04:22,450 --> 00:04:24,280
正在但是网络的某些部分
are working but some part of the network

110
00:04:24,280 --> 00:04:28,000
损坏或不可靠的这样的部分
is broken or unreliable so partial

111
00:04:28,000 --> 00:04:30,870
失败的另一个原因是
failures is another reason why

112
00:04:30,870 --> 00:04:50,229
分布式系统是很难和最终
distributed systems are hard and a final

113
00:04:50,229 --> 00:04:51,880
之所以很难的，你知道
reason why it's hard is that you know

114
00:04:51,880 --> 00:04:53,289
他们当初之所以建
them the original reason to build the

115
00:04:53,289 --> 00:04:54,780
分布式系统往往能得到
distributed system is often to get

116
00:04:54,780 --> 00:04:57,610
更高的性能，让你知道
higher performance to get you know a

117
00:04:57,610 --> 00:04:59,380
千台电脑价值表现
thousand computers worth of performance

118
00:04:59,380 --> 00:05:01,659
甚至上千元盘武器是的
or a thousand disk arms were the

119
00:05:01,659 --> 00:05:03,580
性能，但它实际上是非常
performance but it's actually very

120
00:05:03,580 --> 00:05:06,820
棘手的获得千倍速
tricky to obtain that thousand X speed

121
00:05:06,820 --> 00:05:09,310
了一千台计算机有
up with a thousand computers there's

122
00:05:09,310 --> 00:05:12,010
往往很多路障扔在你
often a lot of roadblocks thrown in your

123
00:05:12,010 --> 00:05:20,080
方式，使精灵需要一点谨慎
way so the Elven takes a bit of careful

124
00:05:20,080 --> 00:05:22,960
设计使系统实际上给
design to make the system actually give

125
00:05:22,960 --> 00:05:24,270
你表现你觉得你值得拥有
you the performance you feel you deserve

126
00:05:24,270 --> 00:05:26,440
所以解决，当然这些问题
so solving these problems of course

127
00:05:26,440 --> 00:05:27,690
将是所有关于你知道
going to be all about you know

128
00:05:27,690 --> 00:05:31,960
解决这些问题的原因
addressing these issues the reason to

129
00:05:31,960 --> 00:05:33,729
参加课程，是因为经常
take the course is because often the

130
00:05:33,729 --> 00:05:35,409
问题和解决办法都相当
problems and the solutions are quite

131
00:05:35,409 --> 00:05:38,320
只是技术上有趣他们
just technically interesting they're

132
00:05:38,320 --> 00:05:40,330
对于其中一些问题难题
hard problems for some of these problems

133
00:05:40,330 --> 00:05:42,640
有已知相当不错的解决方案
there's pretty good solutions known for

134
00:05:42,640 --> 00:05:44,500
他们没有这么大的其他问题
other problems they're not such great

135
00:05:44,500 --> 00:05:47,740
现在的解决方案分发系统
solutions now distributed systems are

136
00:05:47,740 --> 00:05:50,919
使用了大量真实世界系统的出
used by a lot of real-world systems out

137
00:05:50,919 --> 00:05:53,349
有喜欢大的网站经常参与
there like big websites often involved

138
00:05:53,349 --> 00:05:55,240
你知道广大计算机是
you know vast numbers computers that are

139
00:05:55,240 --> 00:05:57,970
你知道放在一起作为分布式
you know put together as distributed

140
00:05:57,970 --> 00:06:00,430
当我刚开始教学系统
systems when I first started teaching

141
00:06:00,430 --> 00:06:03,490
这当然是分布式系统
this course it was distributed systems

142
00:06:03,490 --> 00:06:05,229
的学术好奇心是什么
were something of an academic curiosity

143
00:06:05,229 --> 00:06:07,659
你认识的人还以为哦，你知道在
you know people thought oh you know at a

144
00:06:07,659 --> 00:06:09,760
他们有时被用于小规模
small scale they were used sometimes and

145
00:06:09,760 --> 00:06:11,080
人们觉得，哦，有一天他们会
people felt that oh someday they'd be

146
00:06:11,080 --> 00:06:14,740
可能是重要的，但现在特别
might be important but now particularly

147
00:06:14,740 --> 00:06:16,690
由巨人网站的兴起带动
driven by the rise of giant websites

148
00:06:16,690 --> 00:06:18,970
有你知道的海量数据
that have you know vast amounts of data

149
00:06:18,970 --> 00:06:21,960
和整个仓库完全电脑
and entire warehouses full of computers

150
00:06:21,960 --> 00:06:23,650
在过去的分布式系统
distributed systems in the last

151
00:06:23,650 --> 00:06:25,860
二十年变得非常
twenty years have gotten to be very

152
00:06:25,860 --> 00:06:29,259
计算的严重重要组成部分
seriously important part of computing

153
00:06:29,259 --> 00:06:32,889
基础设施，这意味着有
infrastructure this means that there's

154
00:06:32,889 --> 00:06:34,479
得到了很多的关注支付给他们
been a lot of attention paid to them a

155
00:06:34,479 --> 00:06:36,250
很多问题都已经解决了，但
lot of problems have been solved but

156
00:06:36,250 --> 00:06:37,690
仍有不少未解
there's still quite a few unsolved

157
00:06:37,690 --> 00:06:39,940
所以，如果你是一个研究生的问题
problems so if you're a graduate student

158
00:06:39,940 --> 00:06:42,490
或者你感兴趣的研究有
or you're interested in research there's

159
00:06:42,490 --> 00:06:45,310
很多你让很多问题还没有
a lot to you let a lot of problems yet

160
00:06:45,310 --> 00:06:47,289
在分布式系统要解决的是
to be solved in distributed systems that

161
00:06:47,289 --> 00:06:49,720
你可以看看他的研究和
you could look into his research and

162
00:06:49,720 --> 00:06:51,639
最后，如果你喜欢的东西建立这个
finally if you like building stuff this

163
00:06:51,639 --> 00:06:54,220
是善类，因为它有一个实验室
is a good class because it has a lab

164
00:06:54,220 --> 00:06:56,050
在你构建一些序列
sequence in which you'll construct some

165
00:06:56,050 --> 00:06:58,690
相当现实的分布式系统
fairly realistic distributed systems

166
00:06:58,690 --> 00:07:00,610
专注于性能和故障
focused on performance and fault

167
00:07:00,610 --> 00:07:01,180
公差
tolerance

168
00:07:01,180 --> 00:07:04,600
所以你有大量的实践建设
so you've got a lot of practice building

169
00:07:04,600 --> 00:07:06,789
区仅有构建分布式
districts just building distributed

170
00:07:06,789 --> 00:07:09,550
系统，使他们的工作好吗
systems and making them work all right

171
00:07:09,550 --> 00:07:12,419
让我谈谈课程结构有点
let me talk about course structure a bit

172
00:07:12,419 --> 00:07:16,539
之前，我开始真实技术
before I get started on real technical

173
00:07:16,539 --> 00:07:19,060
内容，你应该能够找到
content you should be able to find the

174
00:07:19,060 --> 00:07:22,780
使用谷歌和在球场上的网站
course website using Google and on the

175
00:07:22,780 --> 00:07:24,820
当然网站是实验室作业
course website is the lab assignments

176
00:07:24,820 --> 00:07:28,150
和课程安排，并链接到一个
and course schedule and also link to a

177
00:07:28,150 --> 00:07:31,210
广场页面，您可以张贴问题
Piazza page where you can post questions

178
00:07:31,210 --> 00:07:35,320
得到答案的过程中的工作人员，我罗伯特
get answers the course staff I'm Robert

179
00:07:35,320 --> 00:07:36,970
莫里斯我会给予我的讲座
Morris I'll be giving the lectures I

180
00:07:36,970 --> 00:07:39,250
也有TAS你们要站
also have for TAS you guys want to stand

181
00:07:39,250 --> 00:07:44,349
并显示你的面孔是TAS
up and show your faces the TAS are

182
00:07:44,349 --> 00:07:47,949
在特定的专家做
experts at in particular at doing the

183
00:07:47,949 --> 00:07:49,690
解决他们会拿着实验室
solving the labs they'll be holding

184
00:07:49,690 --> 00:07:51,400
上班时间，所以如果您有任何疑问
office hours so if you have questions

185
00:07:51,400 --> 00:07:53,080
有关实验室你能来你应该
about the labs you can come you should

186
00:07:53,080 --> 00:07:55,360
去办公时间，或者你可以发布
go to office hours or you could post

187
00:07:55,360 --> 00:07:59,650
问题来广场的过程中有一个
questions to Piazza the course has a

188
00:07:59,650 --> 00:08:04,030
几个重要的组成部分之一是
couple of important components one is

189
00:08:04,030 --> 00:08:09,099
这个演讲有一个纸差不多
this lectures there's a paper for almost

190
00:08:09,099 --> 00:08:16,380
每次讲座有两个考试
every lecture there's two exams

191
00:08:17,789 --> 00:08:22,650
有编程实验室的实验室和
there's the labs programming labs and

192
00:08:22,650 --> 00:08:25,479
还有一个可选的最终项目
there's an optional final project that

193
00:08:25,479 --> 00:08:28,740
你可以做的实验室之一，而不是
you can do instead of one of the labs

194
00:08:36,039 --> 00:08:38,320
讲座将左右两个大思路
the lectures will be about two big ideas

195
00:08:38,320 --> 00:08:42,070
在分布式系统中他们也将是一个
in distributed systems they'll also be a

196
00:08:42,070 --> 00:08:43,809
夫妇讲座是更多
couple of lectures that are more about

197
00:08:43,809 --> 00:08:47,140
排序的实验室编程的东西很多
sort of lab programming stuff a lot of

198
00:08:47,140 --> 00:08:48,640
我们的演讲会的情况下采取了
our lectures will be taken up by case

199
00:08:48,640 --> 00:08:50,589
研究了很多方式，我有点
studies a lot of the way that I sort of

200
00:08:50,589 --> 00:08:53,650
尽量带出的内容
try to bring out the content of

201
00:08:53,650 --> 00:08:55,210
分布式系统通过观察
distributed systems is by looking at

202
00:08:55,210 --> 00:08:58,110
论文有学者通过一些书面
papers some academics some written by

203
00:08:58,110 --> 00:09:01,960
人们在业内真正描述
people in industry describing real

204
00:09:01,960 --> 00:09:05,100
解决实际问题
solutions to real problems

205
00:09:05,589 --> 00:09:07,589
这些讲座其实是可以录像
these lectures actually be videotaped

206
00:09:07,589 --> 00:09:10,270
而我希望能在网上发布他们如此
and I'm hoping to post them online so

207
00:09:10,270 --> 00:09:12,940
你可以这样，如果你不在这里，或者
that you can so if you're not here or

208
00:09:12,940 --> 00:09:15,279
要查看你会讲座
you want to review the lectures you'll

209
00:09:15,279 --> 00:09:16,270
能看录像带
be able to look at the videotape

210
00:09:16,270 --> 00:09:20,110
讲座试卷再有一到
lectures the papers again there's one to

211
00:09:20,110 --> 00:09:22,060
每周读一大部分研究论文
read per week most of a research paper

212
00:09:22,060 --> 00:09:24,610
他们中的一些经典论文像
some of them are classic papers like

213
00:09:24,610 --> 00:09:26,440
今天的报纸上，我希望你们中的一些
today's paper which I hope some of you

214
00:09:26,440 --> 00:09:28,390
已阅读的MapReduce这是一个旧纸
have read on MapReduce it's an old paper

215
00:09:28,390 --> 00:09:31,390
但它是在其刺激的开始
but it was the beginning of its spurred

216
00:09:31,390 --> 00:09:33,310
有趣的工作，大量的
an enormous amount of interesting work

217
00:09:33,310 --> 00:09:35,860
学术和现实世界中的那么
both academic and in the real world so

218
00:09:35,860 --> 00:09:37,029
有些是经典的，有些是更
some are classic and some are more

219
00:09:37,029 --> 00:09:40,060
最近的论文之类的谈论更多
recent papers sort of talking about more

220
00:09:40,060 --> 00:09:41,500
达最新研究什么人都
up-to-date research what people are

221
00:09:41,500 --> 00:09:44,529
目前担心，并从
currently worried about and from the

222
00:09:44,529 --> 00:09:46,060
我们将希望论文梳理出什么
papers we'll be hoping to tease out what

223
00:09:46,060 --> 00:09:49,120
基本的问题是观念的人是什么
the basic problems are what ideas people

224
00:09:49,120 --> 00:09:50,529
有可能会或可能不会
have had that might or might not be

225
00:09:50,529 --> 00:09:52,180
在解决分布式系统中有用
useful in solving distributed system

226
00:09:52,180 --> 00:09:54,970
我们将着眼于有时问题
problems we'll be looking at sometimes

227
00:09:54,970 --> 00:09:56,650
在一些实施细节
in implementation details in some of

228
00:09:56,650 --> 00:09:58,720
这些文章，因为很多这有
these papers because a lot of this has

229
00:09:58,720 --> 00:10:01,120
做的实际施工
to do with actual construction of of

230
00:10:01,120 --> 00:10:03,430
基于软件的系统和我们也
software based systems and we're also

231
00:10:03,430 --> 00:10:04,900
要花费一定的时间在看
going to spend a certain time looking at

232
00:10:04,900 --> 00:10:07,540
评估人员评估如何故障
evaluations people evaluating how fault

233
00:10:07,540 --> 00:10:09,310
通过测量，宽容他们的系统
tolerant their systems by measuring them

234
00:10:09,310 --> 00:10:11,200
或者人们衡量多少性能
or people measuring how much performance

235
00:10:11,200 --> 00:10:12,790
或者他们是否得到了性能
or whether they got performance

236
00:10:12,790 --> 00:10:17,950
改善在所有所以我希望，
improvement at all so I'm hoping that

237
00:10:17,950 --> 00:10:19,810
你来之前，阅读文件
you'll read the papers before coming to

238
00:10:19,810 --> 00:10:22,660
类讲座也许不会
class the lectures are maybe not going

239
00:10:22,660 --> 00:10:24,220
让尽可能多的意义，如果你还没有
to make as much sense if you haven't

240
00:10:24,220 --> 00:10:26,110
已经阅读讲座，因为有
already read the lecture because there's

241
00:10:26,110 --> 00:10:28,209
没有足够的时间来解释两者都
not enough time to both explaining all

242
00:10:28,209 --> 00:10:30,820
本文的内容和有几分
the content of the paper and have a sort

243
00:10:30,820 --> 00:10:32,830
什么有趣的反思
of interesting reflection on what the

244
00:10:32,830 --> 00:10:35,050
纸是指在线课程让你真正
paper means online class so you really

245
00:10:35,050 --> 00:10:37,209
赶紧去读读报纸我来之前
got to read the papers before I come

246
00:10:37,209 --> 00:10:38,620
进入阶级和的一个有希望
into class and hopefully one of the

247
00:10:38,620 --> 00:10:40,030
的东西，你将学习在这个类是如何
things you'll learn in this class is how

248
00:10:40,030 --> 00:10:42,470
在鱼迅速读报纸
to read a paper rapidly in the fish

249
00:10:42,470 --> 00:10:44,940
而在部分跳过，也许
and skip over the parts that maybe

250
00:10:44,940 --> 00:10:47,430
并不是那么重要和排序的重点
aren't that important and sort of focus

251
00:10:47,430 --> 00:10:51,360
对梳理出的重要思想
on teasing out the important ideas on

252
00:10:51,360 --> 00:10:53,730
该网站有一个为每个环节
the website there's for every link to

253
00:10:53,730 --> 00:10:56,730
购买计划有这么一个问题
buy the schedule there's a question that

254
00:10:56,730 --> 00:10:59,160
你应该提交的答案
you should submit an answer for for

255
00:10:59,160 --> 00:11:00,750
每一个文件，我认为答案是由于
every paper I think the answers are due

256
00:11:00,750 --> 00:11:02,790
在午夜，我们也请您
at midnight and we also ask that you

257
00:11:02,790 --> 00:11:04,020
提交你对一个问题
submit a question you have about the

258
00:11:04,020 --> 00:11:08,070
通过网站纸张，以便既
paper through the website in order both

259
00:11:08,070 --> 00:11:09,390
给我一些思考的
to give me something to think about as

260
00:11:09,390 --> 00:11:11,280
我准备演讲，如果我有
I'm preparing the lecture and if I have

261
00:11:11,280 --> 00:11:13,890
一次，我会尽量回答至少有几个
time I'll try to answer at least a few

262
00:11:13,890 --> 00:11:17,280
通过电子邮件和问题
of the questions by email and the

263
00:11:17,280 --> 00:11:18,600
问题并为每个文件的答案
question and the answer for each paper

264
00:11:18,600 --> 00:11:22,140
由于半夜还有前一天晚上
due midnight the night before there's

265
00:11:22,140 --> 00:11:24,660
两个考试有一个期中考试中
two exams there's a midterm exam in

266
00:11:24,660 --> 00:11:26,850
类我觉得在最后一堂课会议
class I think on the last class meeting

267
00:11:26,850 --> 00:11:32,640
前春假，有一个最终的
before spring break and there's a final

268
00:11:32,640 --> 00:11:36,000
在结束时最后考试周考试
exam during final exam week at the end

269
00:11:36,000 --> 00:11:37,770
本学期的考试要
of the semester the exams are going to

270
00:11:37,770 --> 00:11:42,120
主要集中在论文和实验室和
focus mostly on papers and the labs and

271
00:11:42,120 --> 00:11:44,130
大概做准备的最好方法
probably the best way to prepare for

272
00:11:44,130 --> 00:11:46,320
他们以及听课和
them as well as attending lecture and

273
00:11:46,320 --> 00:11:49,230
看报的好办法准备
reading the papers a good way to prepare

274
00:11:49,230 --> 00:11:51,360
对于考试是看所有考试我们
for the exams is to look at all exams we

275
00:11:51,360 --> 00:11:55,680
有联系的20岁的考试和
have links to 20 years of old exams and

276
00:11:55,680 --> 00:11:57,240
解决方案，所以你看那些和
solutions and so you look at those and

277
00:11:57,240 --> 00:11:58,710
排序得到什么样的感觉
sort of get a feel for what kind of

278
00:11:58,710 --> 00:12:01,350
问题，我想问一下，确实
questions that I like to ask and indeed

279
00:12:01,350 --> 00:12:03,170
因为我们看到许多相同的论文
because we read many of the same papers

280
00:12:03,170 --> 00:12:05,550
不可避免地我每年提问
inevitably I ask questions each year

281
00:12:05,550 --> 00:12:08,910
这不禁类似问题
that can't help but resemble questions

282
00:12:08,910 --> 00:12:15,420
问往年实验室有
asked in previous years the labs there's

283
00:12:15,420 --> 00:12:17,490
编程实验室的第一个
for programming labs the first one of

284
00:12:17,490 --> 00:12:25,650
他们是将于周五公布下周的实验室之一
them is due Friday next week lab one is

285
00:12:25,650 --> 00:12:31,980
一个简单的MapReduce的实验室，以实现你
a simple MapReduce lab to implement your

286
00:12:31,980 --> 00:12:33,810
自己的版本，他们写论文的
own version of the paper they write

287
00:12:33,810 --> 00:12:35,100
今天我将在一个被讨论
today in which I'll be discussing in a

288
00:12:35,100 --> 00:12:36,050
几分钟
few minutes

289
00:12:36,050 --> 00:12:40,320
实验室2涉及使用一种被称为
lab 2 involves using a technique called

290
00:12:40,320 --> 00:12:43,620
筏，以获得故障教
raft in order to get fault taught in

291
00:12:43,620 --> 00:12:47,190
为了某种允许在理论上允许
order to sort of allow in theory allow

292
00:12:47,190 --> 00:12:49,680
任何系统通过进行容错
any system to be made fault tolerant by

293
00:12:49,680 --> 00:12:51,210
复制它，有这个木筏
replicating it and having this raft

294
00:12:51,210 --> 00:12:53,850
技术管理复制和
technique manage the replication and

295
00:12:53,850 --> 00:12:55,230
排序管理自动切
manage sort of automatic cut

296
00:12:55,230 --> 00:12:57,660
或者，如果有一个领域，如果的一个
or if there's a field if one of the

297
00:12:57,660 --> 00:13:00,150
复制服务器失败，所以这是RAV4
replicated servers fails so this is rav4

298
00:13:00,150 --> 00:13:08,700
容错在孩子3，你会用你的
fault tolerance in lad 3 you'll use your

299
00:13:08,700 --> 00:13:11,370
为了实现筏建一个
raft implementation in order to build a

300
00:13:11,370 --> 00:13:18,990
容错键值服务器时，它会
fault tolerant key-value server it'll be

301
00:13:18,990 --> 00:13:22,640
复制并在实验室4容错
replicated and fault tolerant in a lab 4

302
00:13:22,640 --> 00:13:25,950
你把你复制的键值
you'll take your replicated key-value

303
00:13:25,950 --> 00:13:28,200
服务器和克隆成若干
server and clone it into a number of

304
00:13:28,200 --> 00:13:30,390
独立团体，你会分裂
independent groups and you'll split the

305
00:13:30,390 --> 00:13:33,870
在您的键值存储系统数据
data in your key value storage system

306
00:13:33,870 --> 00:13:35,160
在所有这些个别的
across all of these individual

307
00:13:35,160 --> 00:13:36,780
复制组以获得并行
replicated groups to get parallel

308
00:13:36,780 --> 00:13:39,660
加速运行多个复制
speed-up by running multiple replicated

309
00:13:39,660 --> 00:13:42,240
平行组，那么您也
groups in parallel and you'll also be

310
00:13:42,240 --> 00:13:47,790
负责移动各
responsible for moving the various

311
00:13:47,790 --> 00:13:50,070
不同服务器之间的数据块
chunks of data between different servers

312
00:13:50,070 --> 00:13:52,500
他们来去无任何下降
as they come and go without dropping any

313
00:13:52,500 --> 00:13:54,810
球，所以这是一个什么通常被称为
balls so this is a what's often called a

314
00:13:54,810 --> 00:14:03,330
分片键值服务分片
sharded key value service sharding

315
00:14:03,330 --> 00:14:04,830
是指拆分数据
refers to splitting up the data

316
00:14:04,830 --> 00:14:07,410
分隔多个间的数据
partitioning the data among multiple

317
00:14:07,410 --> 00:14:10,290
为了服务器以获得并行速度
servers in order to get parallel speed

318
00:14:10,290 --> 00:14:16,610
如果你还想而不是做实验室4
up if you want instead of doing lab 4

319
00:14:16,610 --> 00:14:19,740
你可以做你自己选择的项目
you can do a project of your own choice

320
00:14:19,740 --> 00:14:21,480
和这里的想法是，如果你有一些
and the idea here is if you have some

321
00:14:21,480 --> 00:14:23,700
主意，你知道分布式系统
idea for a distributed system you know

322
00:14:23,700 --> 00:14:26,010
在一些分布式的风格
in the style of some of the distributed

323
00:14:26,010 --> 00:14:27,330
我们在课堂上，如果谈到系统
systems we talked about in the class if

324
00:14:27,330 --> 00:14:28,530
你有自己的想法，你想
you have your own idea that you want to

325
00:14:28,530 --> 00:14:30,300
追求你喜欢建立的东西
pursue and you like to build something

326
00:14:30,300 --> 00:14:32,100
并测量其是否为了工作
and measure whether it worked in order

327
00:14:32,100 --> 00:14:34,500
探索你的想法，你可以做一个
to explore your idea you can do a

328
00:14:34,500 --> 00:14:38,370
工程等的项目，你会挑
project and so for a project you'll pick

329
00:14:38,370 --> 00:14:40,170
一些队友，因为我们要求
some teammates because we require that

330
00:14:40,170 --> 00:14:44,070
项目中的两个或团队完成
projects are done in teams of two or

331
00:14:44,070 --> 00:14:47,430
三个人那么像一些队友和
three people so like some teammates and

332
00:14:47,430 --> 00:14:49,050
把你的项目的想法我们，我们将
send your project idea to us and we'll

333
00:14:49,050 --> 00:14:50,940
想想看，说是或否，
think about it and say yes or no and

334
00:14:50,940 --> 00:14:53,580
也许给你一些建议，然后，如果
maybe give you some advice and then if

335
00:14:53,580 --> 00:14:55,230
你继续前进，如果我们说是做的，
you go ahead and do if we say yes and

336
00:14:55,230 --> 00:14:56,610
你想做的事你做一个项目，和
you want to do a project you do that and

337
00:14:56,610 --> 00:14:59,160
的实验室4，而不是和它的原因在最后
instead of lab 4 and it's due at the end

338
00:14:59,160 --> 00:15:00,870
这个学期，你知道你会你
of the semester and you know you'll you

339
00:15:00,870 --> 00:15:05,250
应该做一些设计工作，并建立一个
should do some design work and build a

340
00:15:05,250 --> 00:15:06,960
真正的系统，然后在最后一天
real system and then in the last day of

341
00:15:06,960 --> 00:15:08,940
类，你会证明你的系统
class you'll demonstrate your system

342
00:15:08,940 --> 00:15:11,370
以及在很短的那种移交
as well as handing in a short sort of

343
00:15:11,370 --> 00:15:12,900
什么，你给我们书面报告
written report to us about what you

344
00:15:12,900 --> 00:15:17,730
建造和我在网站上发布了一些
built and I posted on the website some

345
00:15:17,730 --> 00:15:20,070
一些想法，这可能会或可能不会
some ideas which might or may not be

346
00:15:20,070 --> 00:15:22,350
对你有用排序冲动的想法
useful for you to sort of spur thoughts

347
00:15:22,350 --> 00:15:25,140
什么项目，你可能建造，但
about what projects you might build but

348
00:15:25,140 --> 00:15:27,690
真的是最好的项目之一，
really the best projects are one where

349
00:15:27,690 --> 00:15:30,090
那种你的一个好主意
sort of you have a good idea for the

350
00:15:30,090 --> 00:15:32,700
项目和想法是，如果你想
project and the idea is if you want to

351
00:15:32,700 --> 00:15:34,920
做一个项目，你应该选择一个想法
do a project you should choose an idea

352
00:15:34,920 --> 00:15:36,810
这是那种在同样的
that's sort of in the same vein as the

353
00:15:36,810 --> 00:15:39,150
在这个被谈论了系统
systems that were talked about in this

354
00:15:39,150 --> 00:15:40,640
类
class

355
00:15:40,640 --> 00:15:44,040
还好回到实验室实验室贪婪是他们
okay back to labs the lab Greed's they

356
00:15:44,040 --> 00:15:46,020
我们给你的手在你的实验室代码
we give you you hand in your lab code

357
00:15:46,020 --> 00:15:47,940
我们运行一些测试反对，
and we run some tests against it and

358
00:15:47,940 --> 00:15:49,710
你是一位伟大的基础上有多少
you're great early based on how many

359
00:15:49,710 --> 00:15:51,870
你通过考试，我们给你所有的测试
tests you pass we give you all the tests

360
00:15:51,870 --> 00:15:55,170
我们使用那些没有任何隐藏的测试，所以如果
that we use those no hidden tests so if

361
00:15:55,170 --> 00:15:56,850
您可靠地实现了实验室，并
you implement the lab and it reliably

362
00:15:56,850 --> 00:15:58,950
通过了所有测试和机会
passes all the tests and chances are

363
00:15:58,950 --> 00:16:00,750
好了，除非有一些有趣的事情
good unless there's something funny

364
00:16:00,750 --> 00:16:02,310
去上有时存在
going on which there sometimes is

365
00:16:02,310 --> 00:16:04,650
有很好的机会，如果你的COOP
chances are good that if you your coop

366
00:16:04,650 --> 00:16:06,060
当你运行它还是通过了所有测试
passes all the tests when you run it or

367
00:16:06,060 --> 00:16:07,560
通过所有的测试，当我们运行它，
pass all the tests when we run it and

368
00:16:07,560 --> 00:16:10,320
你会得到一个4个评分满分如此
you'll get a four score full score so

369
00:16:10,320 --> 00:16:11,520
希望以后还有没有关于谜
hopefully there'll be no mystery about

370
00:16:11,520 --> 00:16:13,830
多少分你可能得上
what score you're likely to get on the

371
00:16:13,830 --> 00:16:18,780
实验室让我提醒你，调试
labs let me warn you that debugging

372
00:16:18,780 --> 00:16:21,930
这些实验室可以耗费时间，因为
these labs can be time-consuming because

373
00:16:21,930 --> 00:16:23,550
他们分布式系统和大量的
they're distributed systems and a lot of

374
00:16:23,550 --> 00:16:26,820
并发和通信类的
concurrency and communication sort of

375
00:16:26,820 --> 00:16:30,000
奇怪的难以调试错误可能
strange difficult to debug errors can

376
00:16:30,000 --> 00:16:34,020
突然出现，所以你真的应该开始
crop up so you really ought to start the

377
00:16:34,020 --> 00:16:37,380
实验室早不这样做，甚至不会有很多
labs early don't don't even have a lot

378
00:16:37,380 --> 00:16:39,210
的麻烦，如果你要经过到最后
of trouble if you be elapsed to the last

379
00:16:39,210 --> 00:16:41,370
此刻你有，如果提前启动
moment you got to start early if your

380
00:16:41,370 --> 00:16:43,680
问题请到办公室TAS
problems please come to the TAS office

381
00:16:43,680 --> 00:16:45,780
小时，请随时提问
hours and please feel free to ask

382
00:16:45,780 --> 00:16:49,080
关于广场和实验室问题
questions about the labs on Piazza and

383
00:16:49,080 --> 00:16:51,270
事实上，我希望，如果你知道答案
indeed I hope if you know the answer

384
00:16:51,270 --> 00:16:52,770
你会回答人的问题上
that you'll answer people's questions on

385
00:16:52,770 --> 00:16:56,339
广场以及所有的权利有任何疑问
Piazza as well all right any questions

386
00:16:56,339 --> 00:17:04,760
关于课程的机制是
about the mechanics of the course yes

387
00:17:10,339 --> 00:17:13,140
所以问题是什么，是怎么做怎么样
so the question is what is how does how

388
00:17:13,140 --> 00:17:15,329
做不同的因素，这些东西
do the different factor these things

389
00:17:15,329 --> 00:17:17,550
融通级我忘了，但它
factoring the grade I forget but it's

390
00:17:17,550 --> 00:17:20,180
所有在它的下网站
all on the it's on the website under

391
00:17:20,180 --> 00:17:24,900
一句话，我认为虽然这是实验室
something I think though it's the labs

392
00:17:24,900 --> 00:17:29,570
是一个最重要的组成部分
are the single most important component

393
00:17:29,570 --> 00:17:36,350
好吧好吧，所以这是一个关于课程
okay alright so this is a course about

394
00:17:36,350 --> 00:17:39,780
应用程序基础设施有关
about infrastructure for applications

395
00:17:39,780 --> 00:17:41,460
所以在这整个过程中有
and so all through this course there's

396
00:17:41,460 --> 00:17:42,809
将要在我的方式排序分裂
going to be a sort of split in the way I

397
00:17:42,809 --> 00:17:45,179
谈谈应用程序之间的事情
talk about things between applications

398
00:17:45,179 --> 00:17:47,550
这是某种其他人
which are sort of other people the

399
00:17:47,550 --> 00:17:49,980
顾客别人写，但
customer somebody else writes but the

400
00:17:49,980 --> 00:17:51,390
应用程序将使用
applications are going to use the

401
00:17:51,390 --> 00:17:53,160
基础设施，我们正在考虑
infrastructure that we're thinking about

402
00:17:53,160 --> 00:17:55,740
在这个过程中，因此该种
in this course and so the kinds of

403
00:17:55,740 --> 00:17:58,950
基础设施，往往会拿出一个
infrastructure that tend to come up a

404
00:17:58,950 --> 00:18:13,620
很多我们的存储和通信
lot our storage communication and

405
00:18:13,620 --> 00:18:16,920
计算，我们将谈论系统
computation and we'll talk about systems

406
00:18:16,920 --> 00:18:19,050
提供所有这三个种的
that provide all three of these kinds of

407
00:18:19,050 --> 00:18:23,370
基础设施的存储事实
infrastructure the the storage it turns

408
00:18:23,370 --> 00:18:24,900
指出，存储将是一个
out that storage is going to be the one

409
00:18:24,900 --> 00:18:27,990
我们专注于最，因为这是一个非常
we focus most on because it's a very

410
00:18:27,990 --> 00:18:30,980
明确定义和有用的抽象和
well-defined and useful abstraction and

411
00:18:30,980 --> 00:18:32,820
通常相当简单
usually fairly straightforward

412
00:18:32,820 --> 00:18:34,320
抽象让人们知道了很多关于
abstraction so people know a lot about

413
00:18:34,320 --> 00:18:36,230
如何建立如何使用和构建
how to build how to use and build

414
00:18:36,230 --> 00:18:40,350
存储系统以及如何构建排序
storage systems and how to build sort of

415
00:18:40,350 --> 00:18:41,670
复制容错
replicated fault tolerant

416
00:18:41,670 --> 00:18:43,679
高性能分布式
high-performance distributed

417
00:18:43,679 --> 00:18:46,410
存储的实现，我们还将
implementations of storage we'll also

418
00:18:46,410 --> 00:18:48,720
谈一些我们的一些计算
talk about some some of our computation

419
00:18:48,720 --> 00:18:50,970
系统如MapReduce的今天是
systems like MapReduce for today is a

420
00:18:50,970 --> 00:18:54,750
计算系统，我们将讨论
computation system and we will talk

421
00:18:54,750 --> 00:18:57,120
有关通信的一些但大多是
about communications some but mostly

422
00:18:57,120 --> 00:18:58,710
从点是一个工具，我们需要
from the point is a tool that we need to

423
00:18:58,710 --> 00:19:00,510
用它来建立分布式系统，如
use to build distributed systems like

424
00:19:00,510 --> 00:19:01,980
计算机具有相互交谈
computers have to talk to each other

425
00:19:01,980 --> 00:19:03,750
在网络上，你也许知道你需要
over a network you know maybe you need

426
00:19:03,750 --> 00:19:06,330
可靠性或东西，所以我们会
reliability or something and so we'll

427
00:19:06,330 --> 00:19:08,670
讨论一下我们实际是
talk a bit about what we're actually

428
00:19:08,670 --> 00:19:11,970
大多消费者的沟通，如果你
mostly consumers of communication if you

429
00:19:11,970 --> 00:19:12,980
想了解通信
want to learn about communication

430
00:19:12,980 --> 00:19:17,040
系统，排序它们是如何工作的是的
systems as sort of how they work that's

431
00:19:17,040 --> 00:19:20,780
六八到九点多的话题
more the topic of six eight to nine

432
00:19:20,780 --> 00:19:24,750
所以对于存储和计算大量的
so for storage and computation a lot of

433
00:19:24,750 --> 00:19:27,200
我们的目标是能够发现
our goal is to be able to discover

434
00:19:27,200 --> 00:19:31,620
抽象其中使用简化的
abstractions where use of simplifying

435
00:19:31,620 --> 00:19:34,440
的界面这两个存储和
the interface to these two storage and

436
00:19:34,440 --> 00:19:36,660
计算分布式存储和
computation distributed storage and

437
00:19:36,660 --> 00:19:38,760
计算基础设施，以便它
computation infrastructure so that it's

438
00:19:38,760 --> 00:19:40,860
容易建立在它之上的应用
easy to build applications on top of it

439
00:19:40,860 --> 00:19:43,500
什么是真正的意思是，我们
and what that really means is that we

440
00:19:43,500 --> 00:19:45,270
需要我们希望能够建立
need to we'd like to be able to build

441
00:19:45,270 --> 00:19:47,370
抽象，隐藏分布
abstraction that hide the distributed

442
00:19:47,370 --> 00:19:51,240
这些这些系统的性质，因此
nature of these of these systems so the

443
00:19:51,240 --> 00:19:54,300
梦想是很少完全实现，但
dream which is rarely fully achieved but

444
00:19:54,300 --> 00:19:56,580
的梦想是能够建立
the dream would be to be able to build

445
00:19:56,580 --> 00:19:58,710
一个界面，看起来到
an interface that looks to an

446
00:19:58,710 --> 00:20:00,630
应用程序是，如果它的分布是非
application is if it's a non distributed

447
00:20:00,630 --> 00:20:02,310
存储系统就像一个文件系统
storage system just like a file system

448
00:20:02,310 --> 00:20:03,750
什么的，每个人都已经
or something that everybody already

449
00:20:03,750 --> 00:20:05,280
知道如何编程，并具有相当
knows how to program and has a pretty

450
00:20:05,280 --> 00:20:08,100
简单的模型语义我们很高兴能够成为
simple model semantics we'd love to be

451
00:20:08,100 --> 00:20:09,990
能够建立接口，它们的外观和
able to build interfaces that look and

452
00:20:09,990 --> 00:20:13,770
行为就像非分布式存储
act just like non distributed storage

453
00:20:13,770 --> 00:20:17,600
和计算系统，但实际上
and computation systems but are actually

454
00:20:17,600 --> 00:20:20,370
你知道广大极高的性能
you know vast extremely high performance

455
00:20:20,370 --> 00:20:22,590
容错分布式系统
fault tolerant distributed systems

456
00:20:22,590 --> 00:20:27,890
下面，所以我们都有抽象
underneath so we both have abstractions

457
00:20:30,020 --> 00:20:33,030
你知道你会为一个疗程看看
and you know as you'll see as a course

458
00:20:33,030 --> 00:20:37,950
接着我们那种只知道一部分
goes on we sort of you know only part of

459
00:20:37,950 --> 00:20:39,810
途中有你找到它的罕见
the way there it's rare that you find an

460
00:20:39,810 --> 00:20:41,820
抽象的分布式版本
abstraction for a distributed version of

461
00:20:41,820 --> 00:20:44,730
存储或计算有简单
storage or computation that has simple

462
00:20:44,730 --> 00:20:49,110
的行为，但他就像非刚
behavior but he's just like the non just

463
00:20:49,110 --> 00:20:51,120
存储即非分布式版本
non distributed version of storage that

464
00:20:51,120 --> 00:20:52,920
大家都明白，但人们越来越
everybody understands but people getting

465
00:20:52,920 --> 00:20:59,640
在此更好，我们要去尝试
better at this and we're gonna try to

466
00:20:59,640 --> 00:21:01,680
学习的方式和人有什么
study the ways and what people have

467
00:21:01,680 --> 00:21:03,860
了解建立这样的抽象概念
learned about building such abstractions

468
00:21:03,860 --> 00:21:08,760
好了，所以什么样什么样的话题
ok so what kind of what kind of topics

469
00:21:08,760 --> 00:21:10,170
露面是我们正在考虑这些
show up is we're considering these

470
00:21:10,170 --> 00:21:13,590
抽象的第一个此第一
abstractions the first one this first

471
00:21:13,590 --> 00:21:15,840
话题常见的主题，我们会看到很多
topic general topic that we'll see a lot

472
00:21:15,840 --> 00:21:18,690
很多系统中，我们看着都
a lot of the systems we looked at have

473
00:21:18,690 --> 00:21:24,920
与实施这样做，例如
to do with implementation so for example

474
00:21:24,920 --> 00:21:27,570
那种工具，你看到很多关于
the kind of tools that you see a lot for

475
00:21:27,570 --> 00:21:30,150
办法的人学习如何建立这些
for ways people learn how to build these

476
00:21:30,150 --> 00:21:31,650
系统之类的东西远程过程
systems are things like remote procedure

477
00:21:31,650 --> 00:21:32,590
呼叫
call

478
00:21:32,590 --> 00:21:35,529
其目的是掩盖事实
whose goal is to mask the fact that

479
00:21:35,529 --> 00:21:36,970
我们在不可靠的通信
we're communicating over an unreliable

480
00:21:36,970 --> 00:21:44,850
网络另一种实施
Network another kind of implementation

481
00:21:44,850 --> 00:21:49,230
话题，我们会看到很多的线程
topic that we'll see a lot is threads

482
00:21:49,230 --> 00:21:51,940
其是一种编程技术，
which are a programming technique that

483
00:21:51,940 --> 00:21:55,029
让我们来线束什么可以让我们
allows us to harness what allows us to

484
00:21:55,029 --> 00:21:56,860
线束多核计算机，但也许
harness multi-core computers but maybe

485
00:21:56,860 --> 00:21:58,749
该类线程更重要
more important for this class threads

486
00:21:58,749 --> 00:22:00,309
是结构化并行的方式
are a way of structuring concurrent

487
00:22:00,309 --> 00:22:03,100
在某种程度上这是希望的操作
operations in a way that's hopefully

488
00:22:03,100 --> 00:22:06,279
简化那些的程序员视图
simplifies the programmer view of those

489
00:22:06,279 --> 00:22:09,100
并行操作和，因为我们
concurrent operations and because we're

490
00:22:09,100 --> 00:22:10,330
要使用线程大量事实证明
gonna use threads a lot it turns out

491
00:22:10,330 --> 00:22:12,279
我们将需要你也知道
we're going to need to also you know

492
00:22:12,279 --> 00:22:13,779
正如从实施层面
just as from an implementation level

493
00:22:13,779 --> 00:22:15,159
花一定的时间思考
spend a certain amount of time thinking

494
00:22:15,159 --> 00:22:16,840
关于并发控制之类的东西
about concurrency control things like

495
00:22:16,840 --> 00:22:25,179
锁和主要场所，这些
locks and the main place that these

496
00:22:25,179 --> 00:22:26,590
实施意见将拿出在
implementation ideas will come up in the

497
00:22:26,590 --> 00:22:28,600
一流的，他们会在很多人被感动的
class they'll be touched on in many of

498
00:22:28,600 --> 00:22:30,190
报纸，但你会来的脸
the papers but you're gonna come face

499
00:22:30,190 --> 00:22:31,869
这一切的在一个大的方式在脸上
the face of all this in a big way in the

500
00:22:31,869 --> 00:22:34,210
你需要建立实验室分布式您
labs you need to build distributed you

501
00:22:34,210 --> 00:22:35,710
知道做编程分布式
know do the programming for distributed

502
00:22:35,710 --> 00:22:38,080
系统，这些都是想了很多种类的
system and these are like a lot of sort

503
00:22:38,080 --> 00:22:41,080
重要的工具，你知道不仅仅是
of important tools you know beyond just

504
00:22:41,080 --> 00:22:43,659
那种普通的编程的这些
sort of ordinary programming these are

505
00:22:43,659 --> 00:22:45,009
一些关键的工具，你会
some of the critical tools that you'll

506
00:22:45,009 --> 00:22:50,279
需要用来构建分布式系统
need to use to build distributed systems

507
00:22:50,279 --> 00:22:54,129
在所有出现的另一大话题
another big topic that comes up in all

508
00:22:54,129 --> 00:22:55,389
报纸上我们要谈的是
the papers we're going to talk about is

509
00:22:55,389 --> 00:23:05,440
性能通常是高层次的目标
performance usually the high-level goal

510
00:23:05,440 --> 00:23:07,570
构建分布式系统是
of building a distributed system is to

511
00:23:07,570 --> 00:23:11,850
让人们所说的可扩展提速
get what people call scalable speed-up

512
00:23:11,850 --> 00:23:17,460
所以我们正在寻找的可扩展性和
so we're looking for scalability and

513
00:23:17,460 --> 00:23:21,039
我所说的可扩展性和可扩展性
what I mean by scalability or scalable

514
00:23:21,039 --> 00:23:23,529
加速是，如果我有一些问题
speed-up is that if I have some problem

515
00:23:23,529 --> 00:23:26,110
说我有一台电脑和我解决
that I'm solving with one computer and I

516
00:23:26,110 --> 00:23:29,559
买第二台电脑帮我执行
buy a second computer to help me execute

517
00:23:29,559 --> 00:23:31,779
我的问题，如果我现在能解决
my problem if I can now solve the

518
00:23:31,779 --> 00:23:34,090
在一半的时间问题，也许解决
problem in half the time or maybe solve

519
00:23:34,090 --> 00:23:37,450
两倍多的问题情况下，你知道
twice as many problem instances you know

520
00:23:37,450 --> 00:23:39,850
每两台计算机上作为分我对
per minute on two computers as I had on

521
00:23:39,850 --> 00:23:42,340
一个那么这就是一个例子
one then that's an example of

522
00:23:42,340 --> 00:23:44,320
这样的可扩展性
scalability so

523
00:23:44,320 --> 00:23:47,560
排序的两倍，你知道计算机或
sort of two times you know computers or

524
00:23:47,560 --> 00:23:54,090
资源让我知道你两次
resources gets me you know two times

525
00:23:54,090 --> 00:24:01,090
性能和吞吐量，这是一个
performance or throughput and this is a

526
00:24:01,090 --> 00:24:02,920
如果你能建立一个系统庞大锤
huge hammer if you can build a system

527
00:24:02,920 --> 00:24:05,170
实际上有这种行为安室奈美惠
that actually has this behavior Namie

528
00:24:05,170 --> 00:24:07,330
如果你加多少
that if you increase the number of

529
00:24:07,330 --> 00:24:08,830
你把这个问题由计算机
computers you throw at the problem by

530
00:24:08,830 --> 00:24:12,190
有些因素你会得到更多的因素
some factor you get that factor more

531
00:24:12,190 --> 00:24:14,650
吞吐量更多表现出来的
throughput more performance out of the

532
00:24:14,650 --> 00:24:17,890
系统，这是一个巨大的胜利，因为你可以
system that's a huge win because you can

533
00:24:17,890 --> 00:24:21,010
买只用钱权计算机
buy computers with just money right

534
00:24:21,010 --> 00:24:23,410
而如果为了得到
whereas if in order to get the

535
00:24:23,410 --> 00:24:27,040
替代这是为了
alternative to this is that in order to

536
00:24:27,040 --> 00:24:28,630
获得更多的性能，你必须支付
get more performance you have to pay

537
00:24:28,630 --> 00:24:31,380
程序员重组软件
programmers to restructure your software

538
00:24:31,380 --> 00:24:33,550
以获得更好的性能，使它
to get better performance to make it

539
00:24:33,550 --> 00:24:35,920
更有效或申请某种
more efficient or to apply some sort of

540
00:24:35,920 --> 00:24:37,900
专业的技术，更好的算法
specialized techniques better algorithms

541
00:24:37,900 --> 00:24:39,970
或东西，如果你要付出
or something if you have to pay

542
00:24:39,970 --> 00:24:42,940
程序员修复你的代码
programmers to fix your code to be

543
00:24:42,940 --> 00:24:45,460
快这是一个昂贵的路要走
faster that's an expensive way to go

544
00:24:45,460 --> 00:24:47,590
我们很乐意能够仅仅通过哦千
we'd love to be able just oh by thousand

545
00:24:47,590 --> 00:24:49,690
计算机而不是10台计算机和
computers instead of ten computers and

546
00:24:49,690 --> 00:24:51,610
获得百倍以上的吞吐量
get a hundred times more throughput

547
00:24:51,610 --> 00:24:53,740
这是梦幻般的，因此这种
that's fantastic and so this sort of

548
00:24:53,740 --> 00:24:56,830
可扩展性的想法是在一个巨大的想法
scalability idea is a huge idea in the

549
00:24:56,830 --> 00:24:58,060
人的头上背上时，他们
backs of people's heads when they're

550
00:24:58,060 --> 00:24:59,560
像建设的东西像大网站
like building things like big websites

551
00:24:59,560 --> 00:25:01,600
运行的是你知道建筑全
that run on are you know building full

552
00:25:01,600 --> 00:25:04,510
电脑如果建筑物充满
of computers if the building full of

553
00:25:04,510 --> 00:25:06,670
电脑是那里得到了几分
computers is there to get a sort of

554
00:25:06,670 --> 00:25:09,610
相应的性能量，但
corresponding amount of performance but

555
00:25:09,610 --> 00:25:12,040
你必须小心设计
you have to be careful about the design

556
00:25:12,040 --> 00:25:13,450
实际上为了获取
in order to actually get that

557
00:25:13,450 --> 00:25:19,780
性能如此频繁的方式，这看起来
performance so often the way this looks

558
00:25:19,780 --> 00:25:21,910
当我们看图表或我
when we're looking at diagrams or I'm

559
00:25:21,910 --> 00:25:23,530
在这个过程中写图是
writing diagrams in this course is that

560
00:25:23,530 --> 00:25:25,480
我不是假设我们正在构建一个
I'm not supposing we're building a

561
00:25:25,480 --> 00:25:27,700
网站通常你可能有一个
website ordinarily you might have a

562
00:25:27,700 --> 00:25:32,080
网站，你知道有一个HTTP服务器
website that you know has a HTTP server

563
00:25:32,080 --> 00:25:36,390
比方说，它有一些类型的用户
let's say it has some types of users

564
00:25:36,900 --> 00:25:42,190
许多Web浏览器和他们聊到网络
many web browsers and they talk to a web

565
00:25:42,190 --> 00:25:44,890
服务器上运行Python或PHP或什么
server running Python or PHP or whatever

566
00:25:44,890 --> 00:25:49,300
这类Web服务器和Web服务器
sort of web server and the web server

567
00:25:49,300 --> 00:25:52,740
会谈某种数据库
talks to some kind of database

568
00:25:54,230 --> 00:25:56,490
你知道当你有一个或两个用户
you know when you have one or two users

569
00:25:56,490 --> 00:25:58,620
你可以有一个计算机运行
you can just have one computer running

570
00:25:58,620 --> 00:26:00,720
两者也许用于Web的计算机
both and maybe a computer for the web

571
00:26:00,720 --> 00:26:02,399
服务器从数据库的计算机
server and a computer from the database

572
00:26:02,399 --> 00:26:03,840
但也许一下子你真的
but maybe all of a sudden you get really

573
00:26:03,840 --> 00:26:05,340
适当的流行，你会起来
proper popular and you'll be up and

574
00:26:05,340 --> 00:26:08,580
你已经知道你有1亿人的标志
you've you know 100 million people sign

575
00:26:08,580 --> 00:26:13,500
你的服务ID怎么你怎么做你
up your service ID how do you how do you

576
00:26:13,500 --> 00:26:15,179
解决您的C-肯定它支持
fix your c-certainly can it support

577
00:26:15,179 --> 00:26:17,899
数以百万计的人在一台计算机上
millions of people on a single computer

578
00:26:17,899 --> 00:26:20,639
通过非常小心除外
except by extremely careful

579
00:26:20,639 --> 00:26:24,629
劳动密集型的优化，但你
labor-intensive optimization but you

580
00:26:24,629 --> 00:26:27,779
没有时间所以通常的办法
don't have time for so typically the way

581
00:26:27,779 --> 00:26:29,519
你要速度的东西了
you're going to speed things up the

582
00:26:29,519 --> 00:26:31,110
你做的第一件事就是买多网
first thing you do is buy more web

583
00:26:31,110 --> 00:26:33,539
服务器和刚刚拆分用户，以便
servers and just split the user so that

584
00:26:33,539 --> 00:26:35,580
你知道如何少数用户或一些分数
you know how few users or some fraction

585
00:26:35,580 --> 00:26:37,230
用户去到Web服务器1，
the user go to a web server 1 and the

586
00:26:37,230 --> 00:26:39,750
另一半，你将它们发送到Web服务器
other half you send them to a web server

587
00:26:39,750 --> 00:26:45,960
2，因为也许你正在构建我
2 and because maybe you're building I

588
00:26:45,960 --> 00:26:47,759
不知道是什么reddit的什么
don't know what reddit or something

589
00:26:47,759 --> 00:26:49,440
所有的用户需要看到相同的
where all the users need to see the same

590
00:26:49,440 --> 00:26:51,210
数据最终你把所有的网页
data ultimately you have all the web

591
00:26:51,210 --> 00:26:54,029
服务器聊到后端，你可以
servers talk to the backend and you can

592
00:26:54,029 --> 00:26:55,559
不断增加的Web服务器很长一段
keep on adding web servers for a long

593
00:26:55,559 --> 00:27:01,679
这里所以这个时候的一种方式
time here and so this is a way of

594
00:27:01,679 --> 00:27:03,029
越来越平行加快在网络上
getting parallel speed up on the web

595
00:27:03,029 --> 00:27:04,259
你知道，如果你正在运行的服务器代码
server code you know if you're running

596
00:27:04,259 --> 00:27:05,909
PHP或者Python，也许它不是太
PHP or Python maybe it's not too

597
00:27:05,909 --> 00:27:09,570
高效只要每一个人网页
efficient as long as each individual web

598
00:27:09,570 --> 00:27:11,490
服务器不放在负载太大
server doesn't put too much load on the

599
00:27:11,490 --> 00:27:12,840
数据库可以添加很多web
database you can add a lot of web

600
00:27:12,840 --> 00:27:17,700
你之前服务器遇到问题，但
servers before you run into problems but

601
00:27:17,700 --> 00:27:20,669
这种可扩展性是很少
this kind of scalability is rarely

602
00:27:20,669 --> 00:27:23,610
无限遗憾的是肯定不会
infinite unfortunately certainly not

603
00:27:23,610 --> 00:27:25,289
没有严肃的思考还等什么
without serious thought and so what

604
00:27:25,289 --> 00:27:26,700
倾向于与这些系统发生的是
tends to happen with these systems is

605
00:27:26,700 --> 00:27:29,309
在某个点之后，你有10个或
that at some point after you have 10 or

606
00:27:29,309 --> 00:27:31,379
20或100的Web服务器都在谈论到
20 or 100 web servers all talking to the

607
00:27:31,379 --> 00:27:33,450
现在同一个数据库中所有的突然
same database now all of a sudden the

608
00:27:33,450 --> 00:27:35,100
启动数据库是一个瓶颈，
database starts to be a bottleneck and

609
00:27:35,100 --> 00:27:37,049
添加更多的Web服务器不再帮助
adding more web servers no longer helps

610
00:27:37,049 --> 00:27:38,909
所以这是罕见的，你得到满量程
so it's rare that you get full scale

611
00:27:38,909 --> 00:27:42,710
能力排序的无限数量的
ability to sort of infinite numbers of

612
00:27:42,710 --> 00:27:44,850
将计算机添加无限数量
adding infinite numbers of computers

613
00:27:44,850 --> 00:27:46,710
某些时候，你气跑了，因为
some point you run out of gas because

614
00:27:46,710 --> 00:27:48,600
这个地方在其中添加更多
the place at which you are adding more

615
00:27:48,600 --> 00:27:51,419
计算机是不再是瓶颈
computers is no longer the bottleneck by

616
00:27:51,419 --> 00:27:52,740
有很多很多的Web服务器，我们
having lots and lots of web servers we

617
00:27:52,740 --> 00:27:54,269
基本上移动瓶颈
basically moved the bottleneck

618
00:27:54,269 --> 00:27:56,549
我认为这是限制从性能
I think it's limiting performance from

619
00:27:56,549 --> 00:28:01,649
web服务器到数据库中，并在
the web servers to the database and at

620
00:28:01,649 --> 00:28:03,450
这一点其实你几乎肯定
this point actually you almost certainly

621
00:28:03,450 --> 00:28:05,730
必须做一些设计工作，因为
have to do a bit of design work because

622
00:28:05,730 --> 00:28:07,590
这是罕见的，你可以
it's rare that you can

623
00:28:07,590 --> 00:28:09,929
有采取任何直接的方法
there's any straightforward way to take

624
00:28:09,929 --> 00:28:13,409
一个单一的数据库和排序的重构
a single database and sort of refactor

625
00:28:13,409 --> 00:28:17,460
用它的东西，或者你可以采取数据
things with it or you can take data

626
00:28:17,460 --> 00:28:19,350
八九不离十在一个单一的数据库重构
sorta in a single database and refactor

627
00:28:19,350 --> 00:28:23,090
它，所以它的分裂在多个数据库
it so it's split over multiple databases

628
00:28:23,840 --> 00:28:26,840
但通常的工作相当数量的和
but it's often a fair amount of work and

629
00:28:26,840 --> 00:28:29,309
因为它是尴尬的，但很多人
because it's awkward but people many

630
00:28:29,309 --> 00:28:32,070
人们真正需要做到这一点我们
people actually need to do this we're

631
00:28:32,070 --> 00:28:33,389
会看到很多的例子在这
gonna see a lot of examples in this

632
00:28:33,389 --> 00:28:34,889
当然，其中分布式系统
course in which the distributed system

633
00:28:34,889 --> 00:28:37,529
人们正在谈论的是一个存储
people are talking about is a storage

634
00:28:37,529 --> 00:28:40,860
系统因为作者正在运行
system because the authors were running

635
00:28:40,860 --> 00:28:42,659
你知道的东西像一个大网站
you know something like a big website

636
00:28:42,659 --> 00:28:45,809
单个数据库上运行的气体从
that ran out of gas on a single database

637
00:28:45,809 --> 00:28:49,429
或存储服务器反正所以
or storage servers anyway so the

638
00:28:49,429 --> 00:28:51,600
可扩展性的故事是我们所爱的构建
scalability story is we love to build

639
00:28:51,600 --> 00:28:56,330
如此规模这样，但你知道系统
systems that scale this way but you know

640
00:28:56,330 --> 00:28:59,100
很难使其或者需要关闭工作
it's hard to make it or takes work off

641
00:28:59,100 --> 00:29:01,950
和设计工作，以推动这一想法
and design work to push this idea

642
00:29:01,950 --> 00:29:11,879
无限远的确定，所以另一个大话题
infinitely far ok so another big topic

643
00:29:11,879 --> 00:29:16,249
自带了很多的容错
that comes up a lot is fault tolerance

644
00:29:22,249 --> 00:29:24,690
如果您正在构建一个系统
if you're building a system with a

645
00:29:24,690 --> 00:29:27,450
在这台计算机以及单
single computer in it well a single

646
00:29:27,450 --> 00:29:29,549
电脑经常可以保持好几年
computer often can stay up for years

647
00:29:29,549 --> 00:29:31,139
像我有服务器在我的办公室里
like I have servers in my office that

648
00:29:31,139 --> 00:29:33,529
已经好几年没有崩溃
have been up for years without crashing

649
00:29:33,529 --> 00:29:35,909
您知道计算机是相当可靠
you know the computer is pretty reliable

650
00:29:35,909 --> 00:29:37,740
操作系统可靠
the operating systems reliable

651
00:29:37,740 --> 00:29:39,690
显然在我的建筑功率
apparently the power in my building is

652
00:29:39,690 --> 00:29:41,639
相当可靠所以它的情况并不少见
pretty reliable so it's not uncommon to

653
00:29:41,639 --> 00:29:43,139
有单台计算机，它只是一个用于
have single computers it's just a for

654
00:29:43,139 --> 00:29:46,590
数量惊人的时间不过如果你是
amazing amount of time however if you're

655
00:29:46,590 --> 00:29:48,149
建筑系统出千的
building systems out of thousands of

656
00:29:48,149 --> 00:29:50,820
电脑那么即使每台计算机都可以
computers then even if each computer can

657
00:29:50,820 --> 00:29:53,700
预计熬夜与一一年
be expected to stay up for a year with a

658
00:29:53,700 --> 00:29:55,320
成千上万的计算机，这意味着你
thousand computers that means you're

659
00:29:55,320 --> 00:29:57,119
将有像约三个电脑
going to have like about three computer

660
00:29:57,119 --> 00:30:00,029
每天失败在您所设定的一个
failures per day in your set of a

661
00:30:00,029 --> 00:30:02,549
千元电脑，所以解决大
thousand computers so solving big

662
00:30:02,549 --> 00:30:04,379
大的分布式系统问题
problems with big distributed systems

663
00:30:04,379 --> 00:30:07,830
原来那种非常罕见的容错
turns sort of very rare fault tolerance

664
00:30:07,830 --> 00:30:10,529
非常现实的故障非常罕见故障
very real failure very rare failure

665
00:30:10,529 --> 00:30:12,179
问题到故障的问题，
problems into failure problems that

666
00:30:12,179 --> 00:30:14,549
刚刚发生的所有的时间在一个系统
happen just all the time in a system

667
00:30:14,549 --> 00:30:15,809
有成千上万的计算机上有几乎
with a thousand computers there's almost

668
00:30:15,809 --> 00:30:18,029
当然总有一些事情打破它
certainly always something broken it's

669
00:30:18,029 --> 00:30:20,580
总有一些计算机要么
always some computer that's either

670
00:30:20,580 --> 00:30:23,070
崩溃或神秘你知道运行
crashed or mysteriously you know running

671
00:30:23,070 --> 00:30:24,840
不正确或慢或做了错误的
incorrectly or slowly or doing the wrong

672
00:30:24,840 --> 00:30:26,940
事情也许有一些片的
thing or maybe there's some piece of the

673
00:30:26,940 --> 00:30:28,890
网络我们有一千台计算机
network with a thousand computers we got

674
00:30:28,890 --> 00:30:31,230
很多网线和大量的
a lot of network cables and a lot of

675
00:30:31,230 --> 00:30:33,600
网络交换机等你知道有
network switches and so you know there's

676
00:30:33,600 --> 00:30:35,100
总有一些网线，有人
always some network cable that somebody

677
00:30:35,100 --> 00:30:37,200
踩到和不可靠性是或
stepped on and is unreliability or

678
00:30:37,200 --> 00:30:38,820
网络电缆脱落的还是一些
network cable that fell out or some

679
00:30:38,820 --> 00:30:40,740
网络，这其风扇损坏和
networks which whose fan is broken and

680
00:30:40,740 --> 00:30:43,260
开关过热和失败的有
the switch overheated and failed there's

681
00:30:43,260 --> 00:30:44,850
总有一些小问题在某处
always some little problem somewhere in

682
00:30:44,850 --> 00:30:48,769
您的建筑尺寸分布式系统
your building sized distributed system

683
00:30:48,769 --> 00:30:52,559
这么大的规模原来的问题，从非常
so big scale turns problems from very

684
00:30:52,559 --> 00:30:54,029
你真的不必罕见事件
rare events you really don't have to

685
00:30:54,029 --> 00:30:56,549
担心这么多逼到不变
worry about that much into just constant

686
00:30:56,549 --> 00:30:59,279
问题这意味着失败有
problems that means the failure has to

687
00:30:59,279 --> 00:31:02,070
真或响应掩蔽
be really or the response the masking of

688
00:31:02,070 --> 00:31:03,720
故障继续运行，没有能力
failures the ability to proceed without

689
00:31:03,720 --> 00:31:05,639
失败只是有被内置到
failures just has to be built into the

690
00:31:05,639 --> 00:31:08,899
设计，因为总是有故障
design because there's always failures

691
00:31:08,899 --> 00:31:12,899
你知道它的部分建筑你的
and you know it's part of building you

692
00:31:12,899 --> 00:31:14,460
知道方便抽象
know convenient abstractions for

693
00:31:14,460 --> 00:31:16,620
我们真正需要的应用程序的程序员
application programmers we really need

694
00:31:16,620 --> 00:31:17,639
那可是要能够建立
that but to be able to build

695
00:31:17,639 --> 00:31:19,350
基础设施，尽可能多地
infrastructure that as much as possible

696
00:31:19,350 --> 00:31:21,899
隐藏应用的故障
hides the failures from application

697
00:31:21,899 --> 00:31:23,929
程序员或口罩他们什么
programmers or masks them or something

698
00:31:23,929 --> 00:31:26,460
让每一个应用程序的程序员
so that every application programmer

699
00:31:26,460 --> 00:31:28,080
不必有一个完整的
doesn't have to have a complete

700
00:31:28,080 --> 00:31:30,510
所有不同复杂的故事
complicated story for all the different

701
00:31:30,510 --> 00:31:35,100
各种可能发生的有故障
kinds of failures that can occur there's

702
00:31:35,100 --> 00:31:37,830
一堆不同的概念，你
a bunch of different notions that you

703
00:31:37,830 --> 00:31:41,159
可以有意味着什么是错
can have about what it means to be fault

704
00:31:41,159 --> 00:31:43,559
沉得住气多一点，但你
tolerant about a little more but you

705
00:31:43,559 --> 00:31:46,679
确切地知道我们所说的，我们会意味着
know exactly what we mean by that we'll

706
00:31:46,679 --> 00:31:48,090
看到很多很多不同口味的
see a lot of a lot of different flavors

707
00:31:48,090 --> 00:31:50,880
但更常见的想法中看到
but among the more common ideas you see

708
00:31:50,880 --> 00:31:58,350
一个是可用性，所以你知道一些
one is availability so you know some

709
00:31:58,350 --> 00:32:01,470
系统被设计成在某些
systems are designed so that under some

710
00:32:01,470 --> 00:32:03,929
一种特定类型的故障并非全部
kind certain kinds of failures not all

711
00:32:03,929 --> 00:32:05,460
失败，但某些种类的故障
failures but certain kinds of failures

712
00:32:05,460 --> 00:32:09,120
该系统将继续运行，尽管
the system will keep operating despite

713
00:32:09,120 --> 00:32:13,139
失败的同时提供你知道
the failure while providing you know

714
00:32:13,139 --> 00:32:16,409
完好的服务相同类型的
undamaged service the same kind of

715
00:32:16,409 --> 00:32:17,820
它会提供即使服务
service it would have provided even if

716
00:32:17,820 --> 00:32:19,500
曾有过没有失败这样一些
there had been no failure so some

717
00:32:19,500 --> 00:32:21,289
系统是在这个意义上，现有
systems are available in that sense that

718
00:32:21,289 --> 00:32:24,149
起来，起来，你知道，所以如果你建立一个
up and up you know so if you build a

719
00:32:24,149 --> 00:32:25,950
也许有两个复制服务
replicated service that maybe has two

720
00:32:25,950 --> 00:32:28,909
你知道其中一个副本复印件
copies you know one of the replicas

721
00:32:28,909 --> 00:32:31,770
副本服务器失败，也许失败
replica servers fail fails maybe the

722
00:32:31,770 --> 00:32:34,530
其他服务器可以继续运行
other server can continue operating

723
00:32:34,530 --> 00:32:37,050
他们都失败，当然你也贵不了
they both fail of course you can't you

724
00:32:37,050 --> 00:32:40,530
知道你不能保证可用性
know you can't promise availability in

725
00:32:40,530 --> 00:32:42,150
这种情况下，通常使现有系统
that case so available systems usually

726
00:32:42,150 --> 00:32:44,670
说好了在某些集的失败
say well under certain set of failures

727
00:32:44,670 --> 00:32:46,140
我们将继续提供
we're going to continue providing

728
00:32:46,140 --> 00:32:48,450
服务我们将提供更多
service we're going to be available more

729
00:32:48,450 --> 00:32:50,790
失败不是发生也不会
failures than that occur it won't be

730
00:32:50,790 --> 00:32:52,730
提供了
available anymore

731
00:32:52,730 --> 00:32:55,080
另一种容错的你
another kind of fault tolerance you

732
00:32:55,080 --> 00:32:57,930
也许你可能有或除
might you might have or in addition to

733
00:32:57,930 --> 00:32:59,130
可用性或通过本身作为
availability or by itself as

734
00:32:59,130 --> 00:33:06,480
可恢复性和这意味着
recoverability and what this means is

735
00:33:06,480 --> 00:33:08,160
如果出现错误的可能
that if something goes wrong maybe the

736
00:33:08,160 --> 00:33:10,200
服务将停止工作，这是
service will stop working that it is

737
00:33:10,200 --> 00:33:13,040
它会简单地停止响应请求
it'll simply stop responding to requests

738
00:33:13,040 --> 00:33:15,780
它会等待有人来
and it will wait for someone to come

739
00:33:15,780 --> 00:33:17,430
沿和修理或什么地方出了错
along and repair or whatever went wrong

740
00:33:17,430 --> 00:33:19,650
但修复后发生的系统
but after the repair occurs the system

741
00:33:19,650 --> 00:33:21,900
将能够继续仿佛什么都没有
will be able to continue as if nothing

742
00:33:21,900 --> 00:33:24,420
坏出了错权，所以这是排序
bad had gone wrong right so this is sort

743
00:33:24,420 --> 00:33:25,590
比较弱的要求
of a weaker requirement than

744
00:33:25,590 --> 00:33:27,810
可用性，因为在这里我们不
availability because here we're not

745
00:33:27,810 --> 00:33:29,640
打算做任何事情，而同时
going to do anything while while the

746
00:33:29,640 --> 00:33:31,140
失败来，直到发生故障的组件
failed come until the failed component

747
00:33:31,140 --> 00:33:33,720
已经修复，但事实是，我们
has been repaired but the fact that we

748
00:33:33,720 --> 00:33:37,230
最多可以得到再次得到去没有你
can get up get going again without you

749
00:33:37,230 --> 00:33:39,510
知道但没有正确的任何损失
know but without any loss of correctness

750
00:33:39,510 --> 00:33:41,880
仍然是一个显著要求它
is still a significant requirement it

751
00:33:41,880 --> 00:33:43,500
意味着你知道可恢复系统
means you know recoverable systems

752
00:33:43,500 --> 00:33:45,690
通常需要做的事情一样保存
typically need to do things like save

753
00:33:45,690 --> 00:33:48,000
在磁盘上或一些他们的最新日期
their latest date on disk or something

754
00:33:48,000 --> 00:33:49,230
在那里他们可以找回来
where they can get it back

755
00:33:49,230 --> 00:33:51,090
你知道电力恢复后，向上
you know after the power comes back up

756
00:33:51,090 --> 00:33:56,010
甚至在现有系统中
and even among available systems in

757
00:33:56,010 --> 00:33:57,870
为了使系统能够在实际有用
order for a system to be useful in real

758
00:33:57,870 --> 00:34:01,890
寿命通常可用什么方式
life usually what the way available

759
00:34:01,890 --> 00:34:04,290
系统SPECT是，他们
systems are SPECT is that they're

760
00:34:04,290 --> 00:34:07,350
可用，直到一些数量的故障
available until some number of failures

761
00:34:07,350 --> 00:34:09,149
发生，如果太多的失败有
have happened if too many failures have

762
00:34:09,149 --> 00:34:11,668
正巧一个可用的系统将停止
happened an available system will stop

763
00:34:11,668 --> 00:34:14,820
工作或你知道会停止响应
working or you know will stop responding

764
00:34:14,820 --> 00:34:18,870
在所有但当足够的事情已经
at all but when enough things have been

765
00:34:18,870 --> 00:34:21,330
修好后它会继续工作这么
repaired it'll continue operating so a

766
00:34:21,330 --> 00:34:23,429
好可用的系统将整理BE的
good available system will sort of be

767
00:34:23,429 --> 00:34:25,139
在敏感可恢复以及
recoverable as well in a sensitive to

768
00:34:25,139 --> 00:34:26,820
许多发生故障
many failures occur

769
00:34:26,820 --> 00:34:28,469
它会停止接听，但随后会
it'll stop answering but then will

770
00:34:28,469 --> 00:34:35,520
正确之后，所以这是继续
continue correctly after that so this is

771
00:34:35,520 --> 00:34:38,429
我们热爱 - 这就是我们很乐意
what we love - this is what we'd love to

772
00:34:38,429 --> 00:34:43,290
获得最大的锤子我们会看到
obtain the biggest hammer what we'll see

773
00:34:43,290 --> 00:34:45,120
一些方法来解决这些
a number of approaches to solving these

774
00:34:45,120 --> 00:34:47,780
问题没什么排序
problems there's really sort of

775
00:34:47,780 --> 00:34:50,179
事情是最重要的工具
things that are the most important tools

776
00:34:50,179 --> 00:34:52,639
我们在这个部门是一个
we have in this department one is

777
00:34:52,639 --> 00:34:55,850
非易失性存储，让你知道
non-volatile storage so that you know

778
00:34:55,850 --> 00:34:58,420
东西崩溃电源故障或任何
something crash power fails or whatever

779
00:34:58,420 --> 00:35:01,310
有一个广泛的建设停电我们
there's a building wide power failure we

780
00:35:01,310 --> 00:35:02,750
可以使用非易失性存储器它像
can use non-volatile store it's like

781
00:35:02,750 --> 00:35:05,330
硬盘驱动器或闪存或固态
hard drives or flash or solid-state

782
00:35:05,330 --> 00:35:07,430
驱动器或东西排序商店A
drives or something to sort of store a

783
00:35:07,430 --> 00:35:12,680
检查点或日志的状态
check point or a log of the state of a

784
00:35:12,680 --> 00:35:14,480
系统，然后当动力来自
system and then when the power comes

785
00:35:14,480 --> 00:35:16,760
备份或某人修理我们的力量
back up or somebody repairs our power

786
00:35:16,760 --> 00:35:18,020
供应商注意什么，我们就可以
suppliers notice what we'll be able to

787
00:35:18,020 --> 00:35:20,510
请阅读我们的最新状态关闭硬盘驱动器
read our latest state off the hard drive

788
00:35:20,510 --> 00:35:24,620
并从那里这么这么一个工具继续
and continue from there so so one tool

789
00:35:24,620 --> 00:35:29,390
是那种非易失性存储器和所述
is sort of non-volatile storage and the

790
00:35:29,390 --> 00:35:31,010
非易失性存储管理刚
management of non-volatile storage just

791
00:35:31,010 --> 00:35:32,840
宁来了很多，因为非易失性
Ning comes up a lot because non-volatile

792
00:35:32,840 --> 00:35:35,000
存储往往是昂贵的更新
storage tends to be expensive to update

793
00:35:35,000 --> 00:35:37,460
所以一个巨大的那种量
and so a huge amount of the sort of

794
00:35:37,460 --> 00:35:39,140
建筑排序的基本事实
nitty-gritty of building sort of

795
00:35:39,140 --> 00:35:42,470
高性能容错系统
high-performance fault-tolerant systems

796
00:35:42,470 --> 00:35:45,290
是你知道聪明的方式，以避免
is in you know clever ways to avoid

797
00:35:45,290 --> 00:35:47,600
具有写入非易失性存储
having to write the non-volatile storage

798
00:35:47,600 --> 00:35:49,970
太多昔日和今日连
too much in the old days and even today

799
00:35:49,970 --> 00:35:53,000
你知道什么是写非易失性
you know what writing non-volatile

800
00:35:53,000 --> 00:35:55,790
存储意味着在动盘臂和
storage meant was moving a disk arm and

801
00:35:55,790 --> 00:35:58,060
等待盘片旋转
waiting for a disk platter to rotate

802
00:35:58,060 --> 00:36:00,920
这两者都是极其缓慢上
both of which are agonizingly slow on

803
00:36:00,920 --> 00:36:04,220
你的规模知道3千兆赫
the scale of you know three gigahertz

804
00:36:04,220 --> 00:36:06,970
微处理器的好东西像Flash
microprocessors good things like flash

805
00:36:06,970 --> 00:36:08,990
生活是一个相当好一点，但仍然
life is quite a bit better but still

806
00:36:08,990 --> 00:36:10,760
需要大量的思想得到很好的
requires a lot of thought to get good

807
00:36:10,760 --> 00:36:12,950
表现出和其他大
performance out of and the other big

808
00:36:12,950 --> 00:36:14,360
工具，我们有容错性
tool we have for fault tolerance is

809
00:36:14,360 --> 00:36:20,000
复制和管理
replication and the management of

810
00:36:20,000 --> 00:36:22,760
复制副本是有点棘手的您
replicated copies is sort of tricky you

811
00:36:22,760 --> 00:36:26,510
知道那种潜伏在问题
know that sort of he problem lurking in

812
00:36:26,510 --> 00:36:28,490
任何复制的系统，我们有两个
any replicated system where we have two

813
00:36:28,490 --> 00:36:30,800
每一个假想相同的服务器
servers each with a supposedly identical

814
00:36:30,800 --> 00:36:34,160
系统状态的关键问题的复制
copy of the system state the key problem

815
00:36:34,160 --> 00:36:36,020
即出现始终是两个
that comes up is always that the two

816
00:36:36,020 --> 00:36:38,600
副本一不小心就会飘出来
replicas will accidentally drift out of

817
00:36:38,600 --> 00:36:41,330
同步和将不再是复制权
sync and will stop being replicas right

818
00:36:41,330 --> 00:36:43,310
而这仅仅是你知道与背部
and this is just you know with the back

819
00:36:43,310 --> 00:36:45,410
每次的设计，我们要看到的
of the every design that we're gonna see

820
00:36:45,410 --> 00:36:47,780
使用复制来获得故障
for using replication to get fault

821
00:36:47,780 --> 00:36:51,260
宽容和实验室 - 很多 - 你所有
tolerance and lab - a lot - you're all

822
00:36:51,260 --> 00:36:53,800
关于管理的管理
about management management of

823
00:36:53,800 --> 00:36:57,450
容错复制拷贝
replicated copies for fault tolerance

824
00:36:57,450 --> 00:37:02,359
因为你会看到它的相当复杂的一个
as you'll see it's pretty complex a

825
00:37:03,740 --> 00:37:10,230
最后一个主题最终跨领域的主题是
final topic final cross-cutting topic is

826
00:37:10,230 --> 00:37:17,549
一致性，所以它的一个例子是我
consistency so it's an example of what I

827
00:37:17,549 --> 00:37:19,430
通过一致性的意思，以为我们是
mean by consistency supposing we're

828
00:37:19,430 --> 00:37:22,079
构建分布式存储系统
building a distributed storage system

829
00:37:22,079 --> 00:37:24,420
这是一个键/值服务，所以它只是
and it's a key/value service so it just

830
00:37:24,420 --> 00:37:26,609
支持两种操作也许有一个
supports two operations maybe there's a

831
00:37:26,609 --> 00:37:29,819
放置操作，你给它一个键，
put operation and you give it a key and

832
00:37:29,819 --> 00:37:33,089
一个值，该存储系统排序
a value and that the storage system sort

833
00:37:33,089 --> 00:37:36,210
储物箱远离下的值作为的
of stashes away the value under as the

834
00:37:36,210 --> 00:37:38,069
此键的值可以保持它只是一个
value for this key maintains it's just a

835
00:37:38,069 --> 00:37:40,079
键和值，然后大表
big table of keys and values and then

836
00:37:40,079 --> 00:37:43,920
有一个很好的操作，你的客户
there's a good operation you the client

837
00:37:43,920 --> 00:37:47,250
发送一条键和存储服务
sends it a key and the storage service

838
00:37:47,250 --> 00:37:49,530
应该知道响应与
is supposed to you know respond with the

839
00:37:49,530 --> 00:37:50,819
它保存价值的价值
value of the value it has stored for

840
00:37:50,819 --> 00:37:52,799
该键右侧，这是一种很好的
that key right and this is kind of good

841
00:37:52,799 --> 00:37:54,780
当我想不出别的如
when I can't think of anything else as

842
00:37:54,780 --> 00:37:56,490
分布式系统的一个例子的所有
an example of a distributed system all

843
00:37:56,490 --> 00:38:00,480
哦不键值服务
Oh without key value services and

844
00:38:00,480 --> 00:38:01,950
他们他们只是非常有用的权利
they're very useful right they're just

845
00:38:01,950 --> 00:38:05,309
排序一种基本的简单的
sort of a kind of fundamental simple

846
00:38:05,309 --> 00:38:09,299
存储系统的版本，所以当然
version of a storage system so of course

847
00:38:09,299 --> 00:38:11,700
如果你是一个应用程序的程序员很
if you're an application programmer it's

848
00:38:11,700 --> 00:38:15,150
有益的，如果这两个操作样的
helpful if these two operations kind of

849
00:38:15,150 --> 00:38:16,799
重视他们，你的意思
have meanings attached to them that you

850
00:38:16,799 --> 00:38:18,630
可以去看看手册和说明书
can go look in the manual and the manual

851
00:38:18,630 --> 00:38:21,299
说，你知道它是什么意思
says you know what it what it means what

852
00:38:21,299 --> 00:38:23,520
你会回来，如果你打电话得到正确的
you'll get back if you call get right

853
00:38:23,520 --> 00:38:25,530
和排序意味着什么给你
and sort of what it means for you to

854
00:38:25,530 --> 00:38:28,109
呼叫被置于没事所以它立即使
call put all right so it's immediate so

855
00:38:28,109 --> 00:38:29,430
某种规范的，因为他们是什么意思
some sort of spec for what they meant

856
00:38:29,430 --> 00:38:31,440
否则就像谁知道你怎么
otherwise like who knows how can you

857
00:38:31,440 --> 00:38:32,880
可能写没有一个应用程序
possibly write an application without a

858
00:38:32,880 --> 00:38:35,250
是什么把得到的是描述
description of what putting get are

859
00:38:35,250 --> 00:38:38,369
应该做的，这是的话题
supposed to do and this is the topic of

860
00:38:38,369 --> 00:38:40,200
一致性和为什么它的原因
consistency and the reason why it's

861
00:38:40,200 --> 00:38:42,329
在分布式系统中有趣的是
interesting in distributed systems is

862
00:38:42,329 --> 00:38:46,200
这两个性能和故障
that both for performance and for fault

863
00:38:46,200 --> 00:38:48,299
宽容的原因容错原因
tolerant reasons fault tolerance reason

864
00:38:48,299 --> 00:38:50,400
我们经常的多个副本
we often have more than one copy of the

865
00:38:50,400 --> 00:38:53,880
数据左右浮动，所以你在知道
data floating around so you know in a

866
00:38:53,880 --> 00:38:55,500
非分布式系统，你只
non distributed system where you just

867
00:38:55,500 --> 00:38:59,130
有一个表中的单个服务器
have a single server with a single table

868
00:38:59,130 --> 00:39:02,579
有经常虽然不总是但
there's often although not always but

869
00:39:02,579 --> 00:39:04,200
经常有像相对不
there's often like relatively no

870
00:39:04,200 --> 00:39:05,940
含糊不清什么布丁GET可能
ambiguity about what pudding get could

871
00:39:05,940 --> 00:39:07,360
可能平均权
possibly mean right in

872
00:39:07,360 --> 00:39:08,980
到ative李你知道什么把手段是
to ative Lee you know what put means is

873
00:39:08,980 --> 00:39:10,870
更新表，并得到什么手段
update the table and what get means is

874
00:39:10,870 --> 00:39:12,550
只是让我一个储存在版本
just get me the version that's stored in

875
00:39:12,550 --> 00:39:17,050
但其在分布式表
the table which but in a distributed

876
00:39:17,050 --> 00:39:18,640
系统中有多个副本
system where there's more than one copy

877
00:39:18,640 --> 00:39:20,590
在由于在复制或数据
in the data due to replication or

878
00:39:20,590 --> 00:39:23,890
缓存或谁知道有可能是
caching or who knows what there may be

879
00:39:23,890 --> 00:39:30,130
许多不同版本的这个关键的
lots of different versions of this key

880
00:39:30,130 --> 00:39:32,380
值对左右浮动一样，如果一个
value pair floating around like if one

881
00:39:32,380 --> 00:39:34,030
的副本，你知道，如果假设
of the replicas you know if supposing

882
00:39:34,030 --> 00:39:36,910
一些客户发出看跌期权，你知道
some client issues a put and you know

883
00:39:36,910 --> 00:39:43,030
还有的服务器的两个副本等等
there's two copies of the the server so

884
00:39:43,030 --> 00:39:48,070
他们都有一个键值右表
they both have a key value table right

885
00:39:48,070 --> 00:39:51,550
也许关键一个有值20上
and maybe key one has value twenty on

886
00:39:51,550 --> 00:39:55,360
他们两个，然后一些客户端问题
both of them and then some client issues

887
00:39:55,360 --> 00:39:58,990
认沽不错，我们有客户在这里和
a put nice we have client over here and

888
00:39:58,990 --> 00:40:00,310
它会发送它要更新认沽
it's gonna send a put it wants to update

889
00:40:00,310 --> 00:40:03,490
一个值是21全部
the value of one to be twenty-one all

890
00:40:03,490 --> 00:40:04,960
右也许它计算的东西，在这
right maybe it's counting stuff in this

891
00:40:04,960 --> 00:40:09,550
键值服务器，以便将与主要看跌
key value server so sends a put with key

892
00:40:09,550 --> 00:40:13,750
一个和值21将其发送到
one and value twenty one it sends it to

893
00:40:13,750 --> 00:40:15,840
第一个服务器，它是关于送
the first server and it's about to send

894
00:40:15,840 --> 00:40:18,010
你知道同放要更新
the same put you know wants to update

895
00:40:18,010 --> 00:40:20,380
这两个副本的权利也让他们在同步
both copies right it keeps them in sync

896
00:40:20,380 --> 00:40:22,300
它是关于发送此看跌，但只是
it's about to send this put but just

897
00:40:22,300 --> 00:40:23,530
之前将其发送到付诸第二
before it sends to put to the second

898
00:40:23,530 --> 00:40:26,950
服务器崩溃我电源故障或错误的
server crashes I power failure or bug an

899
00:40:26,950 --> 00:40:28,690
所以现在的操作系统或东西
operating system or something so now the

900
00:40:28,690 --> 00:40:30,640
状态留在伤心地是，我们派出
state were left in sadly is that we sent

901
00:40:30,640 --> 00:40:35,470
该看跌期权的，所以我们已经更新了一个
this put and so we've updated one of the

902
00:40:35,470 --> 00:40:37,300
两个副本没有值20
two replicas didn't have value twenty

903
00:40:37,300 --> 00:40:38,590
之一，但其他的人仍然具有二十
one but the other ones still with twenty

904
00:40:38,590 --> 00:40:40,870
现在有人走来，并与读取
now somebody comes along and reads with

905
00:40:40,870 --> 00:40:42,910
一大家子，他们可能会得到他们想要
a get and they might get they want to

906
00:40:42,910 --> 00:40:45,070
阅读与关键一个关联的值
read the value associated with key one

907
00:40:45,070 --> 00:40:46,420
他们可能会得到21或者他们可能
they might get twenty one or they might

908
00:40:46,420 --> 00:40:48,100
这取决于他们要向谁倾诉得到20
get twenty depending on who they talk to

909
00:40:48,100 --> 00:40:50,350
即使规则是你总是说话
and even if the rule is you always talk

910
00:40:50,350 --> 00:40:52,600
顶端服务器首先，如果你是
to the top server first if you're

911
00:40:52,600 --> 00:40:53,830
建立一个容错系统
building a fault-tolerant system the

912
00:40:53,830 --> 00:40:56,020
实际的规则必须是哦，你去跟
actual rule has to be oh you talk to the

913
00:40:56,020 --> 00:40:58,000
顶级服务器首先，除非它是失败的
top server first unless it's failed in

914
00:40:58,000 --> 00:41:00,810
你跟底部的服务器这种情况下，
which case you talk to the bottom server

915
00:41:00,810 --> 00:41:03,640
所以哪天方式任你风险暴露
so either way someday you risk exposing

916
00:41:03,640 --> 00:41:06,610
数据的一些陈旧的这个副本
this stale copy of the data to some

917
00:41:06,610 --> 00:41:08,650
将来再次它可能是很多变
future again it could be that many gets

918
00:41:08,650 --> 00:41:10,630
获得更新的21，然后像
get the updated twenty one and then like

919
00:41:10,630 --> 00:41:12,730
下周一下子有些人会
next week all of a sudden some get

920
00:41:12,730 --> 00:41:14,920
国债收益率你知道的一个星期旧副本
yields you know a week old copy of the

921
00:41:14,920 --> 00:41:19,370
数据，这样不是很一致
data so that's not very consistent

922
00:41:19,370 --> 00:41:23,720
右所以要想但你知道它的
right so in order but you know it's the

923
00:41:23,720 --> 00:41:25,870
这样的事情可能发生的权利
kind of thing that could happen right

924
00:41:25,870 --> 00:41:29,210
我们不小心，所以你知道我们需要
we're not careful so you know we need to

925
00:41:29,210 --> 00:41:32,420
有我们需要真正写下
have we need to actually write down what

926
00:41:32,420 --> 00:41:33,920
该规则将是关于puts和
the rules are going to be about puts and

927
00:41:33,920 --> 00:41:36,650
被赋予由于这种危险
gets given this danger of due to

928
00:41:36,650 --> 00:41:39,230
复制和原来有
replication and it turns out there's

929
00:41:39,230 --> 00:41:42,650
许多不同的定义，你可以有
many different definitions you can have

930
00:41:42,650 --> 00:41:47,030
一致性的，你知道有很多是
of consistency you know many of them are

931
00:41:47,030 --> 00:41:48,470
它们的相对简单的多
relatively straightforward many of them

932
00:41:48,470 --> 00:41:52,940
听起来很好，我得到的收益率，你
sound like well I get yields the you

933
00:41:52,940 --> 00:41:55,250
知道大多数最近值看跌期权
know value put by the most recently

934
00:41:55,250 --> 00:42:00,170
完成把所有的权利，这样的
completed put all right so that's

935
00:42:00,170 --> 00:42:02,960
通常被称为强一致性，
usually called strong consistency it

936
00:42:02,960 --> 00:42:05,390
事实证明也这是构建非常有用
turns out also it's very useful to build

937
00:42:05,390 --> 00:42:06,740
有弱得多系统
systems that have much weaker

938
00:42:06,740 --> 00:42:08,660
一致性有比如不
consistency there for example do not

939
00:42:08,660 --> 00:42:11,990
就像一个GET保证任何看到
guarantee anything like a get sees the

940
00:42:11,990 --> 00:42:15,170
由最近放写入值和
value written by the most recent put and

941
00:42:15,170 --> 00:42:18,440
之所以这么有强烈的存在
the reason so there's there strongly

942
00:42:18,440 --> 00:42:23,030
他们通常有一致的系统
consistent systems they usually have

943
00:42:23,030 --> 00:42:25,130
一些版本，被看到最近
some version that gets seen most recent

944
00:42:25,130 --> 00:42:27,290
看跌期权虽然你必须有很多
puts although you have to there's a lot

945
00:42:27,290 --> 00:42:28,820
的细节工作，在那里也
of details to work out there's also

946
00:42:28,820 --> 00:42:32,180
每周一致许多种类的味道
weekly consistent many sort of flavors

947
00:42:32,180 --> 00:42:33,830
不每周一致系统
of weekly consistent systems that do not

948
00:42:33,830 --> 00:42:36,650
作出任何保证你知道
make any such guarantee that you know

949
00:42:36,650 --> 00:42:38,870
可以保证你离你知道，如果
may guarantee well you're you know if

950
00:42:38,870 --> 00:42:41,690
有人不看跌，那么你可能看不到
someone does a put then you may not see

951
00:42:41,690 --> 00:42:43,610
认沽您可能会看到旧值即
the put you may see old values that

952
00:42:43,610 --> 00:42:45,740
没有被放了一个更新
weren't updated by the put for an

953
00:42:45,740 --> 00:42:49,070
时间无限量可能与
unbounded amount of time maybe and the

954
00:42:49,070 --> 00:42:51,290
之所以被人们非常感兴趣
reason for people being very interested

955
00:42:51,290 --> 00:42:53,860
在小麦一致性方案是
in wheat consistency schemes is that

956
00:42:53,860 --> 00:42:57,020
即具有雷扎克强一致性
strong consistency that is having Rezac

957
00:42:57,020 --> 00:43:00,860
蔡承租人保证看到的
Chua lessee be guaranteed to see the

958
00:43:00,860 --> 00:43:02,690
最近权，这是一个非常
most recent right that's a very

959
00:43:02,690 --> 00:43:07,190
昂贵的规范来实现的原因是什么
expensive spec to implement because what

960
00:43:07,190 --> 00:43:08,810
它的意思是几乎可以肯定的是你
it means is almost certainly that you

961
00:43:08,810 --> 00:43:10,490
必须要有人做了很多的
have to somebody has to do a lot of

962
00:43:10,490 --> 00:43:12,470
为了通信实际
communication in order to actually

963
00:43:12,470 --> 00:43:14,180
落实强一些概念
implement some notion of strong

964
00:43:14,180 --> 00:43:16,450
一致性，如果您有多个副本
consistency if you have multiple copies

965
00:43:16,450 --> 00:43:20,750
它意味着，或者写入器或
it means that either the writer or the

966
00:43:20,750 --> 00:43:22,490
读者也许既有咨询
reader or maybe both has to consult

967
00:43:22,490 --> 00:43:26,330
每个副本像在这种情况下，你
every copy like in this case where you

968
00:43:26,330 --> 00:43:28,340
知道也许客户端崩溃留下一个
know maybe a client crash left one

969
00:43:28,340 --> 00:43:30,470
更新但如果我们想其他
updated but not the other if we wanted

970
00:43:30,470 --> 00:43:31,820
落实强
to implement strong

971
00:43:31,820 --> 00:43:33,710
西瑟顿从中看到，也许一个简单的方法
Sisseton see in them maybe a simple way

972
00:43:33,710 --> 00:43:35,210
在这个系统中，我们不得不读者阅读
in this system we'd have readers read

973
00:43:35,210 --> 00:43:37,010
副本，或者如果双方有更多的
both of the copies or if there's more

974
00:43:37,010 --> 00:43:39,560
比一个复制的所有副本，并使用
than one copy all the copies and use the

975
00:43:39,560 --> 00:43:41,270
最近写入的价值，他们
most recently written value that they

976
00:43:41,270 --> 00:43:44,870
发现但这是昂贵的，这是一个很大
find but that's expensive that's a lot

977
00:43:44,870 --> 00:43:49,640
闲聊中读取一个值，所以在
of chitchat to read one value so in

978
00:43:49,640 --> 00:43:51,620
为了尽可能避免通信
order to avoid communication as much as

979
00:43:51,620 --> 00:43:54,680
可能特别是如果副本是
possible particularly if replicas are

980
00:43:54,680 --> 00:43:56,810
远离人们建立弱电系统是
far away people build weak systems that

981
00:43:56,810 --> 00:43:59,480
实际上可能允许的读取过时
might actually allow the stale read of

982
00:43:59,480 --> 00:44:02,840
在这种情况下，虽然旧的价值
an old value in this case although

983
00:44:02,840 --> 00:44:05,540
有附着往往更语义
there's often more semantics attached to

984
00:44:05,540 --> 00:44:06,980
即尽量使这些薄弱方案
that to try to make these weak schemes

985
00:44:06,980 --> 00:44:10,370
更有用，我们这个通信
more useful and we're this communication

986
00:44:10,370 --> 00:44:13,420
问题你知道强一致性
problem you know strong consistency

987
00:44:13,420 --> 00:44:16,850
需要昂贵的通信，其中
requiring expensive communication where

988
00:44:16,850 --> 00:44:19,370
这真的跑你陷入困境IS
this really runs you into trouble is

989
00:44:19,370 --> 00:44:21,500
如果我们使用复制功能
that if we're using replication for

990
00:44:21,500 --> 00:44:24,530
容错那么我们真正想要的
fault tolerance then we really want the

991
00:44:24,530 --> 00:44:26,600
复制品有独立的失败
replicas to have independent failure

992
00:44:26,600 --> 00:44:29,210
概率是不相关的故障
probability to have uncorrelated failure

993
00:44:29,210 --> 00:44:31,850
因此，例如，把双方的
so for example putting both of the

994
00:44:31,850 --> 00:44:34,850
在同伊拉克在我们数据的副本
replicas of our data in the same iraq in

995
00:44:34,850 --> 00:44:37,100
同一机房它可能是一个
the same machine room it's probably a

996
00:44:37,100 --> 00:44:38,360
非常糟糕的主意
really bad idea

997
00:44:38,360 --> 00:44:39,830
因为如果有人绊倒电源
because if someone trips over the power

998
00:44:39,830 --> 00:44:42,410
电缆到机架我们两个副本
cable to that rack both of our copies of

999
00:44:42,410 --> 00:44:44,090
我们的数据会死，因为
our data are going to die because

1000
00:44:44,090 --> 00:44:46,190
他们都连接到相同的电源
they're both attached to the same power

1001
00:44:46,190 --> 00:44:49,730
电缆在同一机架所以在搜索
cable in the same rack so in the search

1002
00:44:49,730 --> 00:44:53,240
制作副本作为独立
for making replicas as independent and

1003
00:44:53,240 --> 00:44:54,980
故障尽可能以获得
failure as possible in order to get

1004
00:44:54,980 --> 00:44:57,860
体面的容错能力的人会爱
decent fault tolerance people would love

1005
00:44:57,860 --> 00:45:00,320
把不同的副本相距甚远
to put different replicas as far apart

1006
00:45:00,320 --> 00:45:02,960
在不同的城市或可能喜欢
as possible like in different cities or

1007
00:45:02,960 --> 00:45:05,210
也许在大陆的两侧
maybe on opposite sides of the continent

1008
00:45:05,210 --> 00:45:07,100
这样的地震，摧毁一个数据
so an earthquake that destroys one data

1009
00:45:07,100 --> 00:45:09,260
中心将极不可能
center will be extremely unlikely to

1010
00:45:09,260 --> 00:45:11,840
也会破坏其他数据中心
also destroy the other data center that

1011
00:45:11,840 --> 00:45:15,860
与其他副本，你知道的，所以我们很乐意
as the other copy you know so we'd love

1012
00:45:15,860 --> 00:45:17,420
要能做到这一点，如果你这样做
to be able to do that if you do that

1013
00:45:17,420 --> 00:45:20,660
那么另一份是千
then the other copy is thousands of

1014
00:45:20,660 --> 00:45:23,660
英里远和的速率光
miles away and the rate at which light

1015
00:45:23,660 --> 00:45:26,480
行进装置，它可能需要在
travels means that it may take on the

1016
00:45:26,480 --> 00:45:28,550
毫秒或几十秒的顺序
order of milliseconds or tens of

1017
00:45:28,550 --> 00:45:31,670
毫秒传送到数据
milliseconds to communicate to a data

1018
00:45:31,670 --> 00:45:33,380
为了整个非洲大陆的中心，
center across the continent in order to

1019
00:45:33,380 --> 00:45:36,590
更新数据等其他副本
update the other copy of the data and so

1020
00:45:36,590 --> 00:45:38,450
这使得该通信
that makes this the communication

1021
00:45:38,450 --> 00:45:40,610
需要良好的强一致性
required for strong consistency for good

1022
00:45:40,610 --> 00:45:42,350
一致性可能极其
consistency potentially extremely

1023
00:45:42,350 --> 00:45:44,450
昂贵的像你想要做的每一次
expensive like every time you want to do

1024
00:45:44,450 --> 00:45:45,319
这些放歌剧之一
one of these put opera

1025
00:45:45,319 --> 00:45:46,999
也许这也取决于你如何
or maybe again depending on how you

1026
00:45:46,999 --> 00:45:49,099
实现它，你可能会坐在那里
implement it you might have to sit there

1027
00:45:49,099 --> 00:45:50,509
等待像10或20或30
waiting for like 10 or 20 or 30

1028
00:45:50,509 --> 00:45:52,940
毫秒以谈话既
milliseconds in order to talk to both

1029
00:45:52,940 --> 00:45:54,650
数据的副本，以确保
copies of the data to ensure that

1030
00:45:54,650 --> 00:45:56,749
他们俩都更新或或托运
they're both updated or or both checked

1031
00:45:56,749 --> 00:46:01,359
找到最新的副本，以及
to find the latest copy and that

1032
00:46:01,359 --> 00:46:04,039
巨大的代价权，这是10或
tremendous expense right this is 10 or

1033
00:46:04,039 --> 00:46:06,079
20或30毫秒上的机器，
20 or 30 milliseconds on machines that

1034
00:46:06,079 --> 00:46:07,789
毕竟，我会执行像一个十亿
after all I'll execute like a billion

1035
00:46:07,789 --> 00:46:09,499
条指令每秒所以我们浪费
instructions per second so we're wasting

1036
00:46:09,499 --> 00:46:11,539
很多潜在的指令，而我们
a lot of potential instructions while we

1037
00:46:11,539 --> 00:46:14,509
等待的人经常去弱得多系统
wait people often go much weaker systems

1038
00:46:14,509 --> 00:46:16,009
你被允许只更新
you're allowed to only update the

1039
00:46:16,009 --> 00:46:17,779
最近的复制你只是咨询
nearest copy you're only consulted

1040
00:46:17,779 --> 00:46:20,089
最近的复制我的意思是有一个巨大的排序
nearest copy I mean there's a huge sort

1041
00:46:20,089 --> 00:46:23,140
学术和现实世界中的量
of amount of academic and real-world

1042
00:46:23,140 --> 00:46:26,839
如何组织薄弱的研究
research on how to structure weak

1043
00:46:26,839 --> 00:46:28,099
一致性保证所以他们
consistency guarantees so they're

1044
00:46:28,099 --> 00:46:30,380
真正有用的应用程序，以及如何
actually useful to applications and how

1045
00:46:30,380 --> 00:46:31,759
利用这些优势，以
to take advantage of them in order to

1046
00:46:31,759 --> 00:46:36,349
实际上得到高性能这么好吗
actually get high performance alright so

1047
00:46:36,349 --> 00:46:40,150
这是的闪电预览
that's a lightning preview of the

1048
00:46:40,150 --> 00:46:43,729
在使用过程中的技术思路任何
technical ideas in the course any

1049
00:46:43,729 --> 00:46:46,339
关于这个问题，我开始之前
questions about this before I start

1050
00:46:46,339 --> 00:46:50,869
谈及MapReduce的我想没事
talking about MapReduce all right I want

1051
00:46:50,869 --> 00:46:54,049
要切换到地图减少，这是一个排序
to switch to Map Reduce that's a sort of

1052
00:46:54,049 --> 00:46:55,519
详细的案例研究，实际上是
detailed case study that's actually

1053
00:46:55,519 --> 00:46:57,949
要说明大部分意见
going to illustrate most of the ideas

1054
00:46:57,949 --> 00:47:02,420
我们已经现在这里所说的
that we've been talking about here now

1055
00:47:02,420 --> 00:47:07,779
产生本来是一个系统
produces a system that was originally

1056
00:47:07,779 --> 00:47:11,989
设计和建造，并通过谷歌我用
designed and built and used by Google I

1057
00:47:11,989 --> 00:47:15,140
认为纸的历史可以追溯到2004年
think the paper dates back to 2004 the

1058
00:47:15,140 --> 00:47:17,269
他们面临的问题是，
problem they were faced with was that

1059
00:47:17,269 --> 00:47:20,900
他们上运行庞大的计算
they were running huge computations on

1060
00:47:20,900 --> 00:47:22,759
TB的和类似的数据的TB的
terabytes and terabytes of data like

1061
00:47:22,759 --> 00:47:27,170
创建所有内容的索引
creating an index of all of the content

1062
00:47:27,170 --> 00:47:29,660
网页或分析的链接
of the web or analyzing the link

1063
00:47:29,660 --> 00:47:32,359
整个网络的，以便结构，以
structure of the entire web in order to

1064
00:47:32,359 --> 00:47:35,029
找出最重要的网页或
identify the most important pages or the

1065
00:47:35,029 --> 00:47:37,219
最权威的网页，你知道
most authoritative pages as you know the

1066
00:47:37,219 --> 00:47:39,140
整个网络就是在那些日子里，甚至
whole web is what's even in those days

1067
00:47:39,140 --> 00:47:45,079
几十数据构建指数的TB的
tens of terabytes of data building index

1068
00:47:45,079 --> 00:47:47,029
网络的基本上等同于一个
of the web is basically equivalent to a

1069
00:47:47,029 --> 00:47:49,729
排序运行排序整个数据
sort running sort of the entire data

1070
00:47:49,729 --> 00:47:52,069
那种你知道那些喜欢合理
sort you know ones like reasonably

1071
00:47:52,069 --> 00:47:55,339
价格昂贵，在其上运行排序
expensive and to run a sort on the

1072
00:47:55,339 --> 00:47:56,630
整个内容我去过的方式
entire content to the way I've been a

1073
00:47:56,630 --> 00:47:58,130
单台计算机
single computer

1074
00:47:58,130 --> 00:47:59,990
多久会采取，但你知道
how long would have taken but you know

1075
00:47:59,990 --> 00:48:01,940
这是周或数月或数年或
it's weeks or months or years or

1076
00:48:01,940 --> 00:48:04,309
事情因此谷歌的时间为
something so Google the time was

1077
00:48:04,309 --> 00:48:06,200
不顾一切地能够运行巨人
desperate to be able to run giant

1078
00:48:06,200 --> 00:48:08,539
对数以千计的巨型数据计算
computations on giant data on thousands

1079
00:48:08,539 --> 00:48:10,670
为了电脑的
of computers in order that the

1080
00:48:10,670 --> 00:48:12,980
计算可以快速地完成它的
computations could finish rapidly it's

1081
00:48:12,980 --> 00:48:14,210
值得给他们买很多
worth it to them to buy lots of

1082
00:48:14,210 --> 00:48:16,400
电脑让他们的工程师
computers so that their engineers

1083
00:48:16,400 --> 00:48:17,720
就不必花费大量的时间
wouldn't have to spend a lot of time

1084
00:48:17,720 --> 00:48:19,519
读报纸什么的
reading the newspaper or something

1085
00:48:19,519 --> 00:48:22,039
等待他们的大计算作业
waiting for their big compute jobs to

1086
00:48:22,039 --> 00:48:27,410
光洁度等一会儿他们有
finish and so for a while they had their

1087
00:48:27,410 --> 00:48:29,630
聪明的工程师或排序手写的你
clever engineer or sort of handwrite you

1088
00:48:29,630 --> 00:48:30,619
知道，如果你需要写一个网页
know if you needed to write a web

1089
00:48:30,619 --> 00:48:32,930
索引或某种林肯支出的一
indexer or some sort of Lincoln outlay a

1090
00:48:32,930 --> 00:48:35,809
眨眼分析工具，你知道谷歌
blink analysis tool you know Google

1091
00:48:35,809 --> 00:48:37,130
买了台电脑，他们说这里
bought the computers and they say here

1092
00:48:37,130 --> 00:48:38,599
你知道工程师们写，但从来没有
engineers you know do write but never

1093
00:48:38,599 --> 00:48:39,890
任何软件，你喜欢这些
whatever software you like on these

1094
00:48:39,890 --> 00:48:41,269
电脑，你知道他们会
computers and you know they would

1095
00:48:41,269 --> 00:48:44,230
费力LY写的那种一次性的
laborious ly write the sort of one-off

1096
00:48:44,230 --> 00:48:46,279
手动咬伤软件采取
manually bitten software to take

1097
00:48:46,279 --> 00:48:47,660
任何问题，他们正在上
whatever problem they were working on

1098
00:48:47,660 --> 00:48:49,609
所以以某种方式外包出去了很多
and so to somehow farm it out to a lot

1099
00:48:49,609 --> 00:48:51,470
计算机和组织
of computers and organize that

1100
00:48:51,470 --> 00:48:56,809
计算并得到，如果你的数据备份
computation and get the data back if you

1101
00:48:56,809 --> 00:48:58,539
只雇佣谁是技术熟练的工程师
only hire engineers who are skilled

1102
00:48:58,539 --> 00:49:01,789
分布式系统的专家也许这就是
distributed systems experts maybe that's

1103
00:49:01,789 --> 00:49:04,190
OK，虽然即使这样，它可能是很
ok although even then it's probably very

1104
00:49:04,190 --> 00:49:07,490
浪费的工程设计工作，但他们的
wasteful of engineering effort but they

1105
00:49:07,490 --> 00:49:09,289
想雇用谁是熟练的人
wanted to hire people who were skilled

1106
00:49:09,289 --> 00:49:15,009
别的东西，而不一定
at something else and not necessarily

1107
00:49:15,160 --> 00:49:16,910
工程师谁想要把所有的
engineers who wanted to spend all their

1108
00:49:16,910 --> 00:49:18,559
时间编写分布式系统软件
time writing distributed system software

1109
00:49:18,559 --> 00:49:20,359
所以他们真正需要的某种
so they really needed some kind of

1110
00:49:20,359 --> 00:49:22,309
框架，可以很容易地
framework that would make it easy to

1111
00:49:22,309 --> 00:49:26,089
只是他们的工程师写的那种
just have their engineers write the kind

1112
00:49:26,089 --> 00:49:28,130
他们想要的任何分析的胆量
of guts of whatever analysis they wanted

1113
00:49:28,130 --> 00:49:30,140
做这样的排序算法或网页
to do like the sort algorithm or a web

1114
00:49:30,140 --> 00:49:32,990
指数或链接分析仪或任何刚
index or link analyzer or whatever just

1115
00:49:32,990 --> 00:49:34,549
编写应用程序的胆量和
write the guts of that application and

1116
00:49:34,549 --> 00:49:36,740
不能够在成千上万的运行
not be able to run it on a thousands of

1117
00:49:36,740 --> 00:49:39,710
电脑而不必担心
computers without worrying about the

1118
00:49:39,710 --> 00:49:41,539
如何在传播工作细节
details of how to spread the work over

1119
00:49:41,539 --> 00:49:43,730
在数千台电脑如何
the thousands of computers how to

1120
00:49:43,730 --> 00:49:45,950
组织任何数据移动是
organize whatever data movement was

1121
00:49:45,950 --> 00:49:48,349
需要如何应对不可避免的
required how to cope with the inevitable

1122
00:49:48,349 --> 00:49:50,630
失败使他们在寻找一个
failures so they were looking for a

1123
00:49:50,630 --> 00:49:52,009
框架，可以很容易的
framework that would make it easy for

1124
00:49:52,009 --> 00:49:54,740
非专家能够写和
non specialists to be able to write and

1125
00:49:54,740 --> 00:50:00,319
运行大型分布式计算和
run giant distributed computations and

1126
00:50:00,319 --> 00:50:03,609
所以，这就是MapReduce的是所有关于
so that's what MapReduce is all about

1127
00:50:03,609 --> 00:50:06,470
而这个想法是，程序员只
and the idea is that the programmer just

1128
00:50:06,470 --> 00:50:09,930
编写应用程序设计师
write the application designer

1129
00:50:09,930 --> 00:50:12,000
这种分布式计算的消费
consumer of this distributed computation

1130
00:50:12,000 --> 00:50:14,369
我只能够写一个简单的地图
I'm just be able to write a simple map

1131
00:50:14,369 --> 00:50:16,079
功能和简单的功能降低
function and a simple reduce function

1132
00:50:16,079 --> 00:50:18,240
不知道任何有关
that don't know anything about

1133
00:50:18,240 --> 00:50:20,640
分布和MapReduce框架
distribution and the MapReduce framework

1134
00:50:20,640 --> 00:50:25,079
会照顾一切，这样的
would take care of everything else so an

1135
00:50:25,079 --> 00:50:27,869
MapReduce的的是如何抽象什么看法
abstract view of how what MapReduce is

1136
00:50:27,869 --> 00:50:30,900
最多是它开始通过假设
up to is it starts by assuming that

1137
00:50:30,900 --> 00:50:33,030
有一些输入和输入
there's some input and the input is

1138
00:50:33,030 --> 00:50:35,430
分裂成一些一大堆
split up into some a whole bunch of

1139
00:50:35,430 --> 00:50:37,559
不同的文件或数据块以某种方式使
different files or chunks in some way so

1140
00:50:37,559 --> 00:50:43,109
我们想象没有啊，你知道
we're imagining that no yeah you know

1141
00:50:43,109 --> 00:50:51,119
输入文件中的一个，并把文件中的两个等你
input file one and put file two etc you

1142
00:50:51,119 --> 00:50:54,240
知道这些投入也许你知道网络
know these inputs are maybe you know web

1143
00:50:54,240 --> 00:50:55,920
页从网上或多个爬行
pages crawled from the web or more

1144
00:50:55,920 --> 00:50:58,020
可能有点包含大文件
likely sort of big files that contain

1145
00:50:58,020 --> 00:51:00,180
许多网站每个都包含许多网络
many web each of which contains many web

1146
00:51:00,180 --> 00:51:03,420
文件从网页抓取所有权利，
files crawl from the web all right and

1147
00:51:03,420 --> 00:51:04,819
路的Map Reduce
the way Map Reduce

1148
00:51:04,819 --> 00:51:07,950
开始是你找到的地图
starts is that you're to find a map

1149
00:51:07,950 --> 00:51:09,660
功能和MapReduce的框架
function and the MapReduce framework is

1150
00:51:09,660 --> 00:51:15,890
要对每一个运行的地图功能
gonna run your map function on each of

1151
00:51:15,890 --> 00:51:22,200
输入文件，当然你可以
the input files and of course you can

1152
00:51:22,200 --> 00:51:23,190
看到这里有一些明显的
see here there's some obvious

1153
00:51:23,190 --> 00:51:26,970
并行提供可以运行地图
parallelism available can run the maps

1154
00:51:26,970 --> 00:51:28,349
在平行所以每个地图的
in parallel so the each of these map

1155
00:51:28,349 --> 00:51:30,059
功能只是看起来这个输入和
functions only looks as this input and

1156
00:51:30,059 --> 00:51:32,400
产生输出的输出，一个地图
produces output the output that a map

1157
00:51:32,400 --> 00:51:33,990
需要函数，以产生一个
function is required to produce is a

1158
00:51:33,990 --> 00:51:36,750
请列出您知道它需要一个文件作为输入
list you know it takes a file as input

1159
00:51:36,750 --> 00:51:39,750
而文件的某些部分
and the file is some fraction of the

1160
00:51:39,750 --> 00:51:42,180
输入数据和它产生密钥的列表
input data and it produces a list of key

1161
00:51:42,180 --> 00:51:45,619
值对作为输出的映射函数
value pairs as output the map function

1162
00:51:45,619 --> 00:51:48,510
所以例如，让我们假设我们
and so for example let's suppose we're

1163
00:51:48,510 --> 00:51:50,579
写一个最简单的MapReduce的
writing the simplest possible MapReduce

1164
00:51:50,579 --> 00:51:56,400
例如字数MapReduce工作目标
example a word count MapReduce job goal

1165
00:51:56,400 --> 00:51:58,170
是计算出现的次数
is to count the number of occurrences of

1166
00:51:58,170 --> 00:52:00,390
每个字让你的地图功能的威力
each word so your map function might

1167
00:52:00,390 --> 00:52:02,819
发射键值对其中键是
emit key value pairs where the key is

1168
00:52:02,819 --> 00:52:06,930
字和值仅仅是一个如此
the word and the value is just one so

1169
00:52:06,930 --> 00:52:08,910
对于位于C每一个字所以那么这个地图
for every word at C so then this map

1170
00:52:08,910 --> 00:52:10,410
函数将分割输入成
function will split the input up into

1171
00:52:10,410 --> 00:52:11,760
单词或到处ditzies
words or everywhere ditzies

1172
00:52:11,760 --> 00:52:14,309
它发出这个词的关键和1作为
it emits that word as the key and 1 as

1173
00:52:14,309 --> 00:52:16,170
值，然后后来将计
the value and then later on will count

1174
00:52:16,170 --> 00:52:18,359
起来以获得所有的人
up all those ones in order to get the

1175
00:52:18,359 --> 00:52:21,420
最终的输出，让你知道，也许输入1
final output so you know maybe input 1

1176
00:52:21,420 --> 00:52:23,229
有单词
has the word

1177
00:52:23,229 --> 00:52:26,469
一个在它和它等等的字B
a in it and the word B in it and so the

1178
00:52:26,469 --> 00:52:28,569
在地图将要产生的输出是
output the map is going to produce is

1179
00:52:28,569 --> 00:52:32,680
也许键输入值一个键B值一个
key a value one key B value one maybe

1180
00:52:32,680 --> 00:52:35,650
第二不通信看到一个文件
the second not communication sees a file

1181
00:52:35,650 --> 00:52:38,890
该中有一个B和没有别的等等
that has a B in it and nothing else so

1182
00:52:38,890 --> 00:52:43,119
这将可能实现输出B1
it's going to implement output b1 maybe

1183
00:52:43,119 --> 00:52:46,089
此第三输入具有A在它和C
this third input has an A in it and a C

1184
00:52:46,089 --> 00:52:50,140
在好吗，所以我们运行所有这些地图
in it alright so we run all these maps

1185
00:52:50,140 --> 00:52:53,380
在所有输入文件，我们得到这个
on all the input files and we get this

1186
00:52:53,380 --> 00:52:55,059
与纸张的呼叫中间
intermediate with the paper calls

1187
00:52:55,059 --> 00:52:57,130
中间输出这对于每
intermediate output which is for every

1188
00:52:57,130 --> 00:53:00,420
映射的一组密钥值对作为输出的
map a set of key value pairs as output

1189
00:53:00,420 --> 00:53:03,130
然后计算的第二阶段
then the second stage of the computation

1190
00:53:03,130 --> 00:53:07,059
是运行减少和想法
is to run the reduces and the idea is

1191
00:53:07,059 --> 00:53:09,459
该MapReduce框架收集
that the MapReduce framework collects

1192
00:53:09,459 --> 00:53:12,609
从所有地图一起所有实例
together all instances from all maps of

1193
00:53:12,609 --> 00:53:15,130
每个键字所以MapReduce框架
each key word so the MapReduce framework

1194
00:53:15,130 --> 00:53:16,869
是要收集了所有的
is going to collect together all of the

1195
00:53:16,869 --> 00:53:20,739
一个就是你从每个地图每个键知道
A's you know from every map every key

1196
00:53:20,739 --> 00:53:22,599
值对，其关键是它的要
value pair whose key was a it's gonna

1197
00:53:22,599 --> 00:53:28,289
需要将它们收集齐全，并将它们交给
take collect them all and hand them to

1198
00:53:30,390 --> 00:53:33,069
程序员的一个打电话找
one call of the programmer to find

1199
00:53:33,069 --> 00:53:35,529
减少功能，那么它将会讲解
reduce function and then it's gonna take

1200
00:53:35,529 --> 00:53:38,319
所有B的，并收集在一起的
all the B's and collect them together of

1201
00:53:38,319 --> 00:53:39,699
当然，你知道需要一个真正的
course you know requires a real

1202
00:53:39,699 --> 00:53:42,339
集合，因为他们是不同的
collection because they were different

1203
00:53:42,339 --> 00:53:44,019
密钥B的实例是由产生
instances of key B were produced by

1204
00:53:44,019 --> 00:53:46,989
在地图上的不同的指示
different indications of map on

1205
00:53:46,989 --> 00:53:48,609
不同的电脑，所以我们不是在谈论
different computers so we're not talking

1206
00:53:48,609 --> 00:53:50,680
有关数据移动我，所以我们要去
about data movement I'm so we're gonna

1207
00:53:50,680 --> 00:53:53,339
收集所有B密钥，并将它们交给
collect all the B keys and hand them to

1208
00:53:53,339 --> 00:53:58,719
不同的电话，以减少具有所有
a different call to reduce that has all

1209
00:53:58,719 --> 00:54:01,959
所述乙键作为其参数和相同的
of the B keys as its arguments and same

1210
00:54:01,959 --> 00:54:07,630
为C所以有将是
as C so there's going to be the

1211
00:54:07,630 --> 00:54:09,160
MapReduce框架将安排一个
MapReduce framework will arrange for one

1212
00:54:09,160 --> 00:54:11,769
呼吁减少对每个密钥
call to reduce for every key that

1213
00:54:11,769 --> 00:54:17,140
发生于任何数学输出和
occurred in any of the math output and

1214
00:54:17,140 --> 00:54:19,449
你知道我们的那种愚蠢的字
you know for our sort of silly word

1215
00:54:19,449 --> 00:54:23,499
算上例如所有这些都降低到
count example all these reduces have to

1216
00:54:23,499 --> 00:54:25,059
做或其中任何一个要做的就是
do or any one of them has to do is just

1217
00:54:25,059 --> 00:54:28,329
数传递给它的项目数
count the number of items passed to it

1218
00:54:28,329 --> 00:54:29,650
甚至不必看项目
doesn't even have to look at the items

1219
00:54:29,650 --> 00:54:31,059
因为它知道他们每个人是
because it knows that each of them is

1220
00:54:31,059 --> 00:54:34,479
这个词是负责加一
the word is responsible for plus one is

1221
00:54:34,479 --> 00:54:35,769
值你没有看
the value you don't have to look at

1222
00:54:35,769 --> 00:54:36,880
比不上那些我们刚刚统计
those ones we've just count

1223
00:54:36,880 --> 00:54:41,590
所以这种减少会产生和
so this reduce is going to produce a and

1224
00:54:41,590 --> 00:54:44,580
那么它的投入计数这个降低
then the count of its inputs this reduce

1225
00:54:44,580 --> 00:54:47,680
它会产生相关的关键
it's going to produce the key associated

1226
00:54:47,680 --> 00:54:50,350
它再算上它的价值
with it and then count of its values

1227
00:54:50,350 --> 00:54:57,040
这也有两个，所以这是一个什么
which is also two so this is what a

1228
00:54:57,040 --> 00:55:01,990
典型的MapReduce工作看起来像
typical MapReduce job looks like the

1229
00:55:01,990 --> 00:55:07,200
高级别只是为了完整性
high level just for completeness the

1230
00:55:07,200 --> 00:55:09,100
还有一些术语的一点点
well some a little bit of terminology

1231
00:55:09,100 --> 00:55:12,480
整个计算被称为工作
the whole computation is called the job

1232
00:55:12,480 --> 00:55:16,900
的MapReduce任何调用被称为
anyone invocation of MapReduce is called

1233
00:55:16,900 --> 00:55:19,000
一个任务，使我们整个的工作，
a task so we have the entire job and

1234
00:55:19,000 --> 00:55:21,010
它是由一群数学任务了
it's made up of a bunch of math tasks

1235
00:55:21,010 --> 00:55:27,220
然后一束产生任务，以便
and then a bunch of produced tasks so

1236
00:55:27,220 --> 00:55:29,860
这是这个词的例子算你
it's an example for this word count you

1237
00:55:29,860 --> 00:55:31,150
知道地图是什么，并减少
know the what the map and reduce

1238
00:55:31,150 --> 00:55:40,750
功能看起来像地图
functions would look like the map

1239
00:55:40,750 --> 00:55:45,130
功能取入值作为密钥
function takes a key in the value as

1240
00:55:45,130 --> 00:55:46,420
争论现在我们谈论
arguments and now we're talking about

1241
00:55:46,420 --> 00:55:48,070
功能类似于写在一个普通的
functions like written in an ordinary

1242
00:55:48,070 --> 00:55:51,520
编程语言如C ++或Java或
programming language like C++ or Java or

1243
00:55:51,520 --> 00:55:54,820
谁知道所以这只是代码
who knows what so this is just code

1244
00:55:54,820 --> 00:55:57,160
人们一般人可以写什么
people ordinary people can write what a

1245
00:55:57,160 --> 00:55:58,870
地图功能的字数会做的是
map function for word count would do is

1246
00:55:58,870 --> 00:56:02,920
分裂的关键是程序文件名
split the the key is the file name which

1247
00:56:02,920 --> 00:56:05,110
通常被忽略，我们真正关心什么
typically is ignored we really care what

1248
00:56:05,110 --> 00:56:07,600
文件名是和V是
the file name was and the V is the

1249
00:56:07,600 --> 00:56:12,250
这个内容映射输入文件，因此V是
content of this maps input file so V is

1250
00:56:12,250 --> 00:56:14,400
你知道刚才包含所有的这段文字
you know just contains all this text

1251
00:56:14,400 --> 00:56:21,760
我们要拆分V输入单词，然后
we're gonna split V into words and then

1252
00:56:21,760 --> 00:56:24,630
每个字
for each word

1253
00:56:30,890 --> 00:56:34,130
我们只是要发出并发出带有两个
we're just gonna emit and emit takes two

1254
00:56:34,130 --> 00:56:36,890
参数手套你知道从容地图即可
arguments mitts you know calmly map can

1255
00:56:36,890 --> 00:56:38,420
使EMIT是由MapReduce的提供
make emit is provided by the MapReduce

1256
00:56:38,420 --> 00:56:41,299
框架我们得到生产我们的手EMIT
framework we get to produce we hand emit

1257
00:56:41,299 --> 00:56:44,890
一个关键这是字和值
a key which is the word and a value

1258
00:56:44,890 --> 00:56:49,730
这是一个字符串，所以这是它
which is the string one so that's it for

1259
00:56:49,730 --> 00:56:53,089
地图功能和字数地图
the map function and a word count map

1260
00:56:53,089 --> 00:56:54,859
功能和MapReduce它字面上
function and MapReduce literally it

1261
00:56:54,859 --> 00:56:56,559
可能是这个简单的
could be this simple

1262
00:56:56,559 --> 00:57:00,309
因此有某种承诺，使
so there's sort of promise to make the

1263
00:57:00,309 --> 00:57:02,599
而你知道这个地图功能不
and you know this map function doesn't

1264
00:57:02,599 --> 00:57:04,190
知道什么分发或
know anything about distribution or

1265
00:57:04,190 --> 00:57:06,170
多台计算机或事实上，我们需要
multiple computers or the fact we need

1266
00:57:06,170 --> 00:57:07,970
我们需要在整个网络中的数据
we need to move data across the network

1267
00:57:07,970 --> 00:57:09,020
或者谁知道
or who knows what

1268
00:57:09,020 --> 00:57:13,400
这是非常简单和
this is extremely straightforward and

1269
00:57:13,400 --> 00:57:19,549
一个字的减少功能计数
the reduce function for a word count the

1270
00:57:19,549 --> 00:57:21,890
减少被调用，你知道记
reduce is called with you know remember

1271
00:57:21,890 --> 00:57:23,329
每减少被调用排序的所有
each reduce is called with sort of all

1272
00:57:23,329 --> 00:57:25,430
在给定的键的情况下，
the instances of a given key on the

1273
00:57:25,430 --> 00:57:27,170
MapReduce框架调用减少
MapReduce framework calls reduce with

1274
00:57:27,170 --> 00:57:30,079
关键在于它是负责和
the key that it's responsible for and a

1275
00:57:30,079 --> 00:57:33,410
所有的矢量值，所述地图
vector of all the values that the maps

1276
00:57:33,410 --> 00:57:38,390
出品与该键相关联的
produced associated with that key the

1277
00:57:38,390 --> 00:57:40,640
关键是这个词的值全部为一
key is the word the values are all ones

1278
00:57:40,640 --> 00:57:41,960
我们不喜欢在这里对他们，我们只
we don't like here about them we only

1279
00:57:41,960 --> 00:57:44,510
关心他们有多少人等
care about how many they were and so

1280
00:57:44,510 --> 00:57:47,420
减轻了自身的省略功能
reduce has its own omit function that

1281
00:57:47,420 --> 00:57:51,200
只是取值被发射以所述
just takes a value to be emitted as the

1282
00:57:51,200 --> 00:57:53,779
作为用于此的值最终输出
final output as the value for the this

1283
00:57:53,779 --> 00:57:57,829
键，我们要承认的长度
key so we're gonna admit a length of

1284
00:57:57,829 --> 00:58:01,789
这个数组所以这也是大约为
this array so this is also about as

1285
00:58:01,789 --> 00:58:04,279
最简单的减少功能有是和
simplest reduce functions have are and

1286
00:58:04,279 --> 00:58:08,049
在地图降低即极其简单
in Map Reduce namely extremely simple

1287
00:58:08,049 --> 00:58:11,480
并且不需要有关故障的知识
and requiring no knowledge about fault

1288
00:58:11,480 --> 00:58:15,859
宽容或任何其他任何好吗
tolerance or anything else alright any

1289
00:58:15,859 --> 00:58:20,529
关于基本框架的问题是
questions about the basic framework yes

1290
00:58:27,390 --> 00:58:30,550
[音乐]
[Music]

1291
00:58:36,099 --> 00:58:39,229
你的意思是你可以喂的输出
you mean can you feed the output of the

1292
00:58:39,229 --> 00:58:48,289
异径那种哦，是哦，是的，在
reducers sort of oh yes oh yes in in in

1293
00:58:48,289 --> 00:58:50,059
在现实生活中所有的权利
in real life all right

1294
00:58:50,059 --> 00:58:53,269
在现实生活中是日常之中
in real life it is routine among

1295
00:58:53,269 --> 00:58:55,939
MapReduce的用户，你知道定义
MapReduce users to you know define a

1296
00:58:55,939 --> 00:58:58,219
MapReduce工作是采取了一些投入和
MapReduce job that took some inputs and

1297
00:58:58,219 --> 00:59:00,169
产生一些输出，然后有一个
produce some outputs and then have a

1298
00:59:00,169 --> 00:59:01,969
第二MapReduce工作你知道你是
second MapReduce job you know you're

1299
00:59:01,969 --> 00:59:03,939
做一些非常复杂的多级
doing some very complicated multistage

1300
00:59:03,939 --> 00:59:08,899
分析或迭代算法等
analysis or iterative algorithm like

1301
00:59:08,899 --> 00:59:10,429
的PageRank例如它是
PageRank for example which is the

1302
00:59:10,429 --> 00:59:13,119
算法谷歌使用排序的
algorithm Google uses to sort of

1303
00:59:13,119 --> 00:59:16,189
估计有重要的影响力或
estimate how important or influential

1304
00:59:16,189 --> 00:59:18,229
不同的网页是这是一个
different webpages are that's an

1305
00:59:18,229 --> 00:59:21,079
迭代算法是那种逐渐
iterative algorithm is sort of gradually

1306
00:59:21,079 --> 00:59:22,939
上一个答案，如果你收敛
converges on an answer and if you

1307
00:59:22,939 --> 00:59:24,439
在MapReduce的实现，我认为
implement in MapReduce which I think

1308
00:59:24,439 --> 00:59:26,539
他们本来你必须运行
they originally did you have to run the

1309
00:59:26,539 --> 00:59:28,909
MapReduce工作多次和
MapReduce job multiple times and the

1310
00:59:28,909 --> 00:59:30,619
每一个的输出是那种你知道
output of each one is sort of you know

1311
00:59:30,619 --> 00:59:34,359
网页使用更新的排序列表
list of webpages with an updated sort of

1312
00:59:34,359 --> 00:59:36,649
值或重量或重要性为每个
value or weight or importance for each

1313
00:59:36,649 --> 00:59:38,359
网页所以这是例行借此
webpage so it was routine to take this

1314
00:59:38,359 --> 00:59:40,279
输出，然后用它作为输入到
output and then use it as the input to

1315
00:59:40,279 --> 00:59:53,749
另一个MapReduce工作哦耶好耶
another MapReduce job oh yeah well yeah

1316
00:59:53,749 --> 00:59:56,029
你需要排序的一套东西了
you need to sort of set things up the

1317
00:59:56,029 --> 00:59:58,279
输出就需要率降低
output you need to rate the reduced

1318
00:59:58,279 --> 00:59:59,269
功能排序的知识
function sort of in the knowledge that

1319
00:59:59,269 --> 01:00:02,659
哦，我需要这是在生产数据
oh I need to produce data that's in the

1320
01:00:02,659 --> 01:00:05,419
格式化或作为信息所需
format or as the information required

1321
01:00:05,419 --> 01:00:07,939
下一个MapReduce工作我的意思是
for the next MapReduce job I mean this

1322
01:00:07,939 --> 01:00:09,229
实际上带来了一点点
actually brings up a little bit of a

1323
01:00:09,229 --> 01:00:11,499
缺点在MapReduce框架
shortcoming in the MapReduce framework

1324
01:00:11,499 --> 01:00:16,309
这是这是伟大的，如果你是，如果
which is it's great if you are if the

1325
01:00:16,309 --> 01:00:18,679
算法需要运行很容易
algorithm you need to run is easily

1326
01:00:18,679 --> 01:00:20,809
表达为一个数学跟此
expressible as a math followed by this

1327
01:00:20,809 --> 01:00:23,869
那种通过洗牌的关键数据
sort of shuffling of the data by key

1328
01:00:23,869 --> 01:00:26,179
随后是减少，这就是它
followed by a reduce and that's it

1329
01:00:26,179 --> 01:00:28,069
我的MapReduce是梦幻般的算法
my MapReduce is fantastic for algorithms

1330
01:00:28,069 --> 01:00:30,589
可以在形式和投我们
that can be cast in that form and we're

1331
01:00:30,589 --> 01:00:32,119
此外，每个地图的必须是
furthermore each of the maps has to be

1332
01:00:32,119 --> 01:00:33,400
完全独立的，
completely independent and

1333
01:00:33,400 --> 01:00:39,520
需要是纯功能性
are required to be functional pure

1334
01:00:39,520 --> 01:00:42,760
功能性的功能，只是看
functional functions that just look at

1335
01:00:42,760 --> 01:00:44,470
他们的论点，没有别的
their arguments and nothing else

1336
01:00:44,470 --> 01:00:46,480
你知道的就像是一个限制
you know that's like it's a restriction

1337
01:00:46,480 --> 01:00:48,640
而事实证明，很多人都希望
and it turns out that many people want

1338
01:00:48,640 --> 01:00:49,990
运行更长的管道是
to run much longer pipelines that

1339
01:00:49,990 --> 01:00:51,430
涉及到许许多多不同类型的
involve lots and lots of different kinds

1340
01:00:51,430 --> 01:00:53,170
处理与MapReduce的你
of processing and with MapReduce you

1341
01:00:53,170 --> 01:00:54,370
有排序凑齐一起的
have to sort of cobble that together

1342
01:00:54,370 --> 01:00:58,390
从多个不同的MapReduce
from multiple MapReduce distinct

1343
01:00:58,390 --> 01:01:00,730
MapReduce作业和更先进的系统
MapReduce jobs and more advanced systems

1344
01:01:00,730 --> 01:01:02,050
我们将在以后的谈
which we will talk about later in the

1345
01:01:02,050 --> 01:01:04,870
当然是在让你更好
course are much better at allowing you

1346
01:01:04,870 --> 01:01:06,520
指定的完整流水线
to specify the complete pipeline of

1347
01:01:06,520 --> 01:01:08,410
计算和他们会做优化
computations and they'll do optimization

1348
01:01:08,410 --> 01:01:10,900
你知道的框架来实现所有
you know the framework realizes all the

1349
01:01:10,900 --> 01:01:13,000
的东西，你必须做的，组织多
stuff you have to do and organize much

1350
01:01:13,000 --> 01:01:15,670
更复杂有效地优化
more complicated efficiently optimize

1351
01:01:15,670 --> 01:01:19,590
更复杂的计算
much more complicated computations

1352
01:01:39,660 --> 01:01:41,650
从程序员的角度来看它
from the programmers point of view it's

1353
01:01:41,650 --> 01:01:44,080
只是地图，从我们的角度减少
just about map and reduce from our point

1354
01:01:44,080 --> 01:01:45,610
来看这将是对
of view it's going to be about the

1355
01:01:45,610 --> 01:01:49,320
工作进程和劳动者服务器
worker processes and the worker servers

1356
01:01:49,320 --> 01:01:53,320
这是他们的MapReduce的一部分
that that are they're part of MapReduce

1357
01:01:53,320 --> 01:01:55,390
框架，在许多其他事情
framework that among many other things

1358
01:01:55,390 --> 01:02:00,000
调用地图和减少功能，使
call the map and reduce functions so

1359
01:02:00,000 --> 01:02:01,930
是啊，从我们的角度来看，我们不在乎
yeah from our point of view we care a

1360
01:02:01,930 --> 01:02:04,240
很多关于如何通过组织
lot about how this is organized by the

1361
01:02:04,240 --> 01:02:06,190
周围的框架，这是有点
surrounding framework this is sort of

1362
01:02:06,190 --> 01:02:08,380
程序员查看所有的
the programmers view with all the

1363
01:02:08,380 --> 01:02:14,340
分配的东西剥离出去是
distributive stuff stripped out yes

1364
01:02:15,960 --> 01:02:25,150
抱歉，我得再说一遍哦，你的意思是
sorry I gotta say it again oh you mean

1365
01:02:25,150 --> 01:02:32,170
哪里的即时数据去好了，
where does the immediate data go okay so

1366
01:02:32,170 --> 01:02:35,440
有两个问题一个是当你
there's two questions one is when you

1367
01:02:35,440 --> 01:02:38,020
调用MIT发生了什么数据和
call a MIT what happens to the data and

1368
01:02:38,020 --> 01:02:42,330
另一种是，其中的功能运行，从而
the other is where the functions run so

1369
01:02:46,910 --> 01:02:50,240
实际的答案是，首先在那里
the actual answer is that first where

1370
01:02:50,240 --> 01:02:53,029
东西烂有一些发言权
the stuff rotten there's a number of say

1371
01:02:53,029 --> 01:02:56,539
一千台服务器UM实际的右边
a thousand servers um actually the right

1372
01:02:56,539 --> 01:02:58,190
看看这里的是人物之一
thing to look at here is figure one in

1373
01:02:58,190 --> 01:03:02,660
本文在此坐在底下
the paper sitting underneath this in the

1374
01:03:02,660 --> 01:03:04,430
现实世界中有一些大集合
real world there's some big collection

1375
01:03:04,430 --> 01:03:09,019
服务器的，我们也许会打电话给他们
of servers and we'll call them maybe

1376
01:03:09,019 --> 01:03:12,410
工人服务器或职工和有
worker servers or workers and there's

1377
01:03:12,410 --> 01:03:14,660
也是一个单一的主服务器的
also a single master server that's

1378
01:03:14,660 --> 01:03:16,519
组织整个计算和
organizing the whole computation and

1379
01:03:16,519 --> 01:03:18,890
这是怎么回事上是高手
what's going on here is the master

1380
01:03:18,890 --> 01:03:22,490
服务器知道知道有一些
server for know knows that there's some

1381
01:03:22,490 --> 01:03:24,559
你知道五个输入文件的数量
number of input files you know five

1382
01:03:24,559 --> 01:03:27,799
千个输入文件，它在养殖场出来
thousand input files and it farms out in

1383
01:03:27,799 --> 01:03:29,539
地图的假期不同
vacations of map to the different

1384
01:03:29,539 --> 01:03:30,890
工人所以它会发送消息到
workers so it'll send a message to

1385
01:03:30,890 --> 01:03:34,180
工人7句话，请你跑知道
worker seven saying please run you know

1386
01:03:34,180 --> 01:03:37,759
在这样和 - 这样的本地图功能
this map function on such-and-such an

1387
01:03:37,759 --> 01:03:41,750
输入文件，然后工人功能
input file and then the worker function

1388
01:03:41,750 --> 01:03:43,400
这是你知道的MapReduce的一部分，
which is you know part of MapReduce and

1389
01:03:43,400 --> 01:03:47,170
知道所有的Map Reduce以及随后
knows all about Map Reduce well then

1390
01:03:47,170 --> 01:03:50,089
读取文件读取输入任何
read the file read the input whatever

1391
01:03:50,089 --> 01:03:54,109
无论输入文件并调用此地图
whichever input file and call this map

1392
01:03:54,109 --> 01:03:56,599
与文件名称值，它的功能
function with the file name value as its

1393
01:03:56,599 --> 01:04:00,400
论据那么工作进程
arguments then that worker process will

1394
01:04:00,400 --> 01:04:02,750
员工在什么它实现和
employees what implements in it and

1395
01:04:02,750 --> 01:04:05,960
每一次地图调用发出工作者
every time the map calls emit the worker

1396
01:04:05,960 --> 01:04:10,279
过程中会将该数据写入文件上
process will write this data to files on

1397
01:04:10,279 --> 01:04:12,769
本地磁盘，从而发生了什么地图
the local disk so what happens to map

1398
01:04:12,769 --> 01:04:17,420
发射是他们生产的文件
emits and is they produce files on the

1399
01:04:17,420 --> 01:04:19,819
映射本地工人的光盘是
map workers local discs that are

1400
01:04:19,819 --> 01:04:21,950
积累的所有键和值
accumulating all the keys and values

1401
01:04:21,950 --> 01:04:26,529
通过对工人运行的地图制作
produced by the maps run on that worker

1402
01:04:26,529 --> 01:04:30,200
所以在数学阶段的到底是什么
so at the end of the math phase what

1403
01:04:30,200 --> 01:04:32,089
我们留下的是所有这些工人
we're left with is all those worker

1404
01:04:32,089 --> 01:04:35,089
机，其中每个都具有的输出
machines each of which has the output of

1405
01:04:35,089 --> 01:04:37,970
一些什么地图都在运行
some of whatever maps were run on that

1406
01:04:37,970 --> 01:04:42,369
工人机那么的MapReduce
worker machine then the MapReduce

1407
01:04:42,369 --> 01:04:45,710
工作人员安排将数据移动到
workers arrange to move the data to

1408
01:04:45,710 --> 01:04:46,819
在那里将是需要的
where it's going to be needed for the

1409
01:04:46,819 --> 01:04:50,240
减少这么既然和你在知道
reduces so and since and a you know in a

1410
01:04:50,240 --> 01:04:53,240
典型的大计算你知道这
typical big computation you know this

1411
01:04:53,240 --> 01:04:55,220
这减少指示将需要
this reduce indication is going to need

1412
01:04:55,220 --> 01:04:59,089
所有地图输出
all map output that

1413
01:04:59,089 --> 01:05:01,559
提到键，但它要去把
mentioned the key a but it's gonna turn

1414
01:05:01,559 --> 01:05:04,289
出你知道这是一个简单的例子
out you know this is a simple example

1415
01:05:04,289 --> 01:05:08,599
但可能在一般每一张地图
but probably in general every single map

1416
01:05:08,599 --> 01:05:10,470
指示将产生大量的
indication will have produce lots of

1417
01:05:10,470 --> 01:05:12,960
按键包括键的某些实例
keys including some instances of key a

1418
01:05:12,960 --> 01:05:15,390
所以通常是为了之前，我们甚至可以
so typically in order before we can even

1419
01:05:15,390 --> 01:05:17,460
运行此功能降低映射减少
run this reduce function the MapReduce

1420
01:05:17,460 --> 01:05:20,190
框架是MapReduce的工作人员
framework that is the MapReduce worker

1421
01:05:20,190 --> 01:05:22,589
我们一千台服务器的一个运行
running on one of our thousand servers

1422
01:05:22,589 --> 01:05:24,269
是将不得不去跟每
is going to have to go talk to every

1423
01:05:24,269 --> 01:05:26,579
单以外的数千个服务器和
single other of the thousand servers and

1424
01:05:26,579 --> 01:05:28,529
比方说看你知道我会运行
say look you know I'm gonna run the

1425
01:05:28,529 --> 01:05:31,170
减少在键请看
reduce for key a please look at the

1426
01:05:31,170 --> 01:05:33,210
存储在中间映射输出的
intermediate map output stored in your

1427
01:05:33,210 --> 01:05:35,880
磁盘捞出所有实例
disk and fish out all of the instances

1428
01:05:35,880 --> 01:05:38,160
关键的一个，并将它们发送网络
of key a and send them over the network

1429
01:05:38,160 --> 01:05:41,069
我这么精简工作打算
to me so the reduce worker is going to

1430
01:05:41,069 --> 01:05:43,529
做到这一点它会从每一个获取
do that it's going to fetch from every

1431
01:05:43,529 --> 01:05:45,960
工人所有关键的实例
worker all of the instances of the key

1432
01:05:45,960 --> 01:05:47,400
这是负责的
that it's responsible for that the

1433
01:05:47,400 --> 01:05:50,339
主人告诉它要负责
master has told it to be responsible for

1434
01:05:50,339 --> 01:05:51,839
一旦它收集到的所有数据的
and once it's collected all of that data

1435
01:05:51,839 --> 01:05:55,819
然后它可以调用减少和降低
then it can call reduce and the reduce

1436
01:05:55,819 --> 01:05:58,470
函数本身调用减少其省略
function itself calls reduce omit which

1437
01:05:58,470 --> 01:06:01,890
是从它的地图，什么不同
is different from the map in it and what

1438
01:06:01,890 --> 01:06:04,710
降低EMIT确实是写入输出
reduces emit does is writes the output

1439
01:06:04,710 --> 01:06:12,150
在集群文件服务，文件
to a file in a cluster file service that

1440
01:06:12,150 --> 01:06:14,519
谷歌使用所以这里的东西我
Google uses so here's something I

1441
01:06:14,519 --> 01:06:17,970
没有提到我没有提到
haven't mentioned I haven't mentioned

1442
01:06:17,970 --> 01:06:21,329
其中输入和生活的地方
where the input lives and where the

1443
01:06:21,329 --> 01:06:25,529
输出住他们两个文件，因为
output lives they're both files because

1444
01:06:25,529 --> 01:06:28,799
任何一块输入我们想要的
any piece of input we want the

1445
01:06:28,799 --> 01:06:31,319
灵活性，能够读取任何片
flexibility to be able to read any piece

1446
01:06:31,319 --> 01:06:34,589
任何工人服务器意味着输入
of input on any worker server that means

1447
01:06:34,589 --> 01:06:36,799
我们需要某种形式的网络文件系统
we need some kind of network file system

1448
01:06:36,799 --> 01:06:42,509
存储输入数据等的确
to store the input data and so indeed

1449
01:06:42,509 --> 01:06:44,099
关于这件事情的文件名为会谈
the paper talks about this thing called

1450
01:06:44,099 --> 01:06:50,160
GFS或谷歌文件系统和GFS是
GFS or Google file system and GFS is a

1451
01:06:50,160 --> 01:06:51,990
集群文件系统和实际BFS
cluster file system and BFS actually

1452
01:06:51,990 --> 01:06:54,210
运行在完全相同的一组工人
runs on exactly the same set of workers

1453
01:06:54,210 --> 01:06:56,720
这项工作我们的服务器是运行的MapReduce
that work our servers that run MapReduce

1454
01:06:56,720 --> 01:07:00,630
和输入只是自动GFS
and the input GFS just automatically

1455
01:07:00,630 --> 01:07:02,220
当你你知道这是一个文件系统，你
when you you know it's a file system you

1456
01:07:02,220 --> 01:07:03,839
可以在我的文件中读取它只是
can read in my files it just

1457
01:07:03,839 --> 01:07:06,119
自动拆分的任何大的文件，你
automatically splits up any big file you

1458
01:07:06,119 --> 01:07:08,490
它存储在许多不同的服务器，并
store on it across lots of servers and

1459
01:07:08,490 --> 01:07:12,320
所以，如果你写64兆点字节的块
64 megabyte chunks so if you write

1460
01:07:12,320 --> 01:07:14,360
如果您查看已爬10 TB的
if you view of ten terabytes of crawled

1461
01:07:14,360 --> 01:07:17,750
网页内容，你只要写
web page contents and you just write

1462
01:07:17,750 --> 01:07:20,120
他们GFS甚至一个大的文件
them to GFS even as a single big file

1463
01:07:20,120 --> 01:07:23,030
GFS会自动拆分广阔
GFS will automatically split that vast

1464
01:07:23,030 --> 01:07:25,010
数据的量成64千字节
amount of data up into 64 kilobyte

1465
01:07:25,010 --> 01:07:28,010
块均匀地分布在所有的
chunks distributed evenly over all of

1466
01:07:28,010 --> 01:07:30,950
政府飞行服务队服务器这是说所有的
the GFS servers which is to say all the

1467
01:07:30,950 --> 01:07:32,510
服务器，谷歌已经可用，
servers that Google has available and

1468
01:07:32,510 --> 01:07:34,580
这是梦幻般的，这只是我们什么
that's fantastic that's just what we

1469
01:07:34,580 --> 01:07:36,860
如果需要我们接着要运行的MapReduce
need if we then want to run a MapReduce

1470
01:07:36,860 --> 01:07:39,650
作业需要整个网页抓取的作为
job that takes the entire crawled web as

1471
01:07:39,650 --> 01:07:42,650
输入数据已经被存储在一个
input the data is already stored in a

1472
01:07:42,650 --> 01:07:44,540
可以跨所有平分方式
way that split up evenly across all the

1473
01:07:44,540 --> 01:07:47,780
服务器，并且使得装置，地图
servers and so that means that the map

1474
01:07:47,780 --> 01:07:49,940
你知道工人我们要发动你
workers you know we're gonna launch you

1475
01:07:49,940 --> 01:07:51,440
知道如果我们有一千台服务器我们
know if we have a thousand servers we're

1476
01:07:51,440 --> 01:07:53,000
要发动每一千个工人地图
gonna launch a thousand map workers each

1477
01:07:53,000 --> 01:07:55,850
在输入数据读取一个1000和
reading one 1000s at the input data and

1478
01:07:55,850 --> 01:07:57,080
他们将能够阅读
they're going to be able to read the

1479
01:07:57,080 --> 01:08:01,460
从一千GFS并行数据
data in parallel from a thousand GFS

1480
01:08:01,460 --> 01:08:04,490
因此，文件服务器越来越现在巨大
file servers thus getting now tremendous

1481
01:08:04,490 --> 01:08:07,730
总读取吞吐量你知道读
total read throughput you know the read

1482
01:08:07,730 --> 01:08:10,960
通过把一个一千台服务器
through put up a thousand servers

1483
01:08:20,990 --> 01:08:23,490
所以这样你在想，也许，谷歌
so so are you thinking maybe that Google

1484
01:08:23,490 --> 01:08:25,470
其中有一组物理机器
has one set of physical machines among

1485
01:08:25,470 --> 01:08:27,779
GFS和一组单独的物理
GFS and a separate set of physical

1486
01:08:27,779 --> 01:08:40,489
机器，运行MapReduce工作好吗
machines that run MapReduce jobs okay

1487
01:08:40,580 --> 01:08:44,790
所以正确的问题是什么呢这
right so the question is what does this

1488
01:08:44,790 --> 01:08:48,630
箭头这里实际上涉及到与
arrow here actually involve and the

1489
01:08:48,630 --> 01:08:50,220
回答这个问题其实是有点改变
answer that actually it sort of changed

1490
01:08:50,220 --> 01:08:51,630
多年来谷歌的
over the years as Google's

1491
01:08:51,630 --> 01:08:55,800
涉及此系统，但你知道吗
involve this system but you know what

1492
01:08:55,800 --> 01:08:58,200
这如果我们有这些一般的情况下
this in those general case if we have

1493
01:08:58,200 --> 01:09:01,080
存储在一些大的网络大文件
big files stored in some big Network

1494
01:09:01,080 --> 01:09:02,880
文件系统一样，你知道它像GFS
file system like you know it's like GFS

1495
01:09:02,880 --> 01:09:05,130
有点像AFS你可能已经使用上
is a bit like AFS you might have used on

1496
01:09:05,130 --> 01:09:07,229
雅典娜，你去跟一些
Athena where you go talk to some

1497
01:09:07,229 --> 01:09:09,810
收集并通过大数据分
collection and your data split over big

1498
01:09:09,810 --> 01:09:11,040
集合O服务器，你必须去谈话
collection o servers you have to go talk

1499
01:09:11,040 --> 01:09:12,149
通过网络向这些服务器
to those servers over the network to

1500
01:09:12,149 --> 01:09:14,580
检索在这种情况下你的数据是什么
retrieve your data in that case what

1501
01:09:14,580 --> 01:09:17,840
此箭头可能代表的是元
this arrow might represent is the meta

1502
01:09:17,840 --> 01:09:20,520
MapReduce的工作进程已熄灭
MapReduce worker process has to go off

1503
01:09:20,520 --> 01:09:22,649
并通过网络交谈的
and talk across the network to the

1504
01:09:22,649 --> 01:09:25,800
正确的GFS服务器或也许服务器的
correct GFS server or maybe servers that

1505
01:09:25,800 --> 01:09:28,350
存储它的部分输入和读取
store it's part of the input and fetch

1506
01:09:28,350 --> 01:09:30,950
它在网络上的MapReduce的
it over the network to the MapReduce

1507
01:09:30,950 --> 01:09:33,450
工人机为了通过地图
worker machine in order to pass the map

1508
01:09:33,450 --> 01:09:35,310
而这肯定是最普遍
and that's certainly the most general

1509
01:09:35,310 --> 01:09:37,920
情况下，那就是最终如何
case and that was eventually how

1510
01:09:37,920 --> 01:09:40,800
MapReduce的实际世界工作
MapReduce actually worked in the world

1511
01:09:40,800 --> 01:09:44,819
本文虽然和，如果你做了
of this paper though and and if you did

1512
01:09:44,819 --> 01:09:45,930
那这是很多网络
that that's a lot of network

1513
01:09:45,930 --> 01:09:47,910
通信，你说约十
communication are you talking about ten

1514
01:09:47,910 --> 01:09:49,350
TB的数据，我们已经搬到10
terabytes of data and we have moved 10

1515
01:09:49,350 --> 01:09:51,600
在他们的数据中心千兆字节
terabytes across their data center

1516
01:09:51,600 --> 01:09:54,270
你知道数据中心网络
network which you know data center

1517
01:09:54,270 --> 01:09:55,740
网络希望每秒吉比特但
networks wanting gigabits per second but

1518
01:09:55,740 --> 01:09:57,780
它仍然是一个大量的时间来搬家几十
it's still a lot of time to move tens of

1519
01:09:57,780 --> 01:10:02,460
为了尽量TB级的数据和
terabytes of data in order to try to and

1520
01:10:02,460 --> 01:10:04,170
的确在本文的世界
indeed in the world of this paper in

1521
01:10:04,170 --> 01:10:07,350
2004年最制约瓶颈
2004 the most constraining bottleneck in

1522
01:10:07,350 --> 01:10:08,850
他们的MapReduce系统是网络
their MapReduce system was Network

1523
01:10:08,850 --> 01:10:11,610
吞吐量，因为他们上运行
throughput because they were running on

1524
01:10:11,610 --> 01:10:13,590
如果你有点读至于网络
a network if you sort of read as far as

1525
01:10:13,590 --> 01:10:18,770
评估部分其网络
the evaluation section their network

1526
01:10:18,770 --> 01:10:24,750
他们的网络是他们有成千上万
their network as was they had thousands

1527
01:10:24,750 --> 01:10:27,230
机
of machines

1528
01:10:27,479 --> 01:10:30,909
不管他们会收集机
whatever and they would collect machines

1529
01:10:30,909 --> 01:10:32,920
他们会堵塞机器，你知道
they would plug machines and you know

1530
01:10:32,920 --> 01:10:35,110
机器的每个机架，你知道的
each rack of machines and you know an

1531
01:10:35,110 --> 01:10:36,519
对于机架式以太网交换机或
Ethernet switch for that rack or

1532
01:10:36,519 --> 01:10:38,110
的东西，但你就知道他们都
something but then you know they all

1533
01:10:38,110 --> 01:10:40,449
需要相互交谈，但有
need to talk to each other but there was

1534
01:10:40,449 --> 01:10:43,989
路由以太网交换机，所有的
a route Ethernet switch that all of the

1535
01:10:43,989 --> 01:10:45,519
落基山脉的净开关交谈和
Rockies are net switches talked to and

1536
01:10:45,519 --> 01:10:47,889
这一次，你知道，所以如果你只是
this one and you know so if you just

1537
01:10:47,889 --> 01:10:51,039
挑选一些地图，减少工人和一些政府飞行服务队
pick some Map Reduce worker and some GFS

1538
01:10:51,039 --> 01:10:52,960
服务器要知道机会是至少
server you know chances are at least

1539
01:10:52,960 --> 01:10:54,880
一半的时间之间的通信
half the time the communication between

1540
01:10:54,880 --> 01:10:56,199
他们必须通过这一个
them has to pass through this one

1541
01:10:56,199 --> 01:10:58,409
不会切换其途径有哪些
wouldn't switch their routes which had

1542
01:10:58,409 --> 01:11:01,479
只有总吞吐量的一定量
only some amount of total throughput

1543
01:11:01,479 --> 01:11:05,650
我忘了你知道的一些数
which I forget you know some number of

1544
01:11:05,650 --> 01:11:09,909
吉比特每秒，我忘记了
gigabits per second and I forget the

1545
01:11:09,909 --> 01:11:13,590
数字很​​好，但，当我做除法
number well but when I did the division

1546
01:11:13,590 --> 01:11:17,889
被划分高达总
that is divided up to the total

1547
01:11:17,889 --> 01:11:19,119
吞吐量路由可用其
throughput available in the routes which

1548
01:11:19,119 --> 01:11:21,639
由大约2000服务器，他们
by the roughly 2000 servers that they

1549
01:11:21,639 --> 01:11:23,769
在论文的实验我用什么
used in the papers experiments what I

1550
01:11:23,769 --> 01:11:26,170
得到的是那的每一台机器共享
got was that each machine share of the

1551
01:11:26,170 --> 01:11:27,999
路由交换机或整个网络的
route switch or of the total network

1552
01:11:27,999 --> 01:11:30,610
容量为只有每秒50兆比特
capacity was only 50 megabits per second

1553
01:11:30,610 --> 01:11:36,309
每秒在其设置50兆位
per second in their setup 50 megabits

1554
01:11:36,309 --> 01:11:41,530
每机器，然后威力第二
per second per machine and then might

1555
01:11:41,530 --> 01:11:43,090
看起来好像很多50兆天哪
seem like a lot 50 megabits gosh

1556
01:11:43,090 --> 01:11:45,429
数以百万计，但它实际上是
millions and millions but it's actually

1557
01:11:45,429 --> 01:11:47,440
相比如何快速一盘相当小
quite small compared to how fast a disks

1558
01:11:47,440 --> 01:11:51,999
罗恩或CPU上运行，因此这与他们的
Ron or CPUs run and so this with their

1559
01:11:51,999 --> 01:11:53,769
网络每秒此50兆比特是
network this 50 megabits per second was

1560
01:11:53,769 --> 01:11:56,440
就像一个巨大的限制，所以他们
like a tremendous limit and so they

1561
01:11:56,440 --> 01:11:57,760
真正站在自己的头
really stood on their heads in the

1562
01:11:57,760 --> 01:12:00,010
在本文设计描述，以避免
design described in the paper to avoid

1563
01:12:00,010 --> 01:12:02,979
利用网络和他们打一个
using the network and they played a

1564
01:12:02,979 --> 01:12:05,860
一堆花样，以避免发送的东西
bunch of tricks to avoid sending stuff

1565
01:12:05,860 --> 01:12:07,059
在网络上时，他们可能
over the network when they possibly

1566
01:12:07,059 --> 01:12:10,570
可避免其中之一是他们
could avoid it one of them was they

1567
01:12:10,570 --> 01:12:14,380
他们会跑了GFS服务器和
would they ran the gfs servers and the

1568
01:12:14,380 --> 01:12:16,809
在同一组的MapReduce的工作人员
MapReduce workers on the same set of

1569
01:12:16,809 --> 01:12:19,059
机，因此他们有一千个
machines so they have a thousand

1570
01:12:19,059 --> 01:12:23,079
机器他们会运行GFS他们实施
machines they'd run GFS they implement

1571
01:12:23,079 --> 01:12:25,090
上千元的GFS服务
their GFS service on that thousand

1572
01:12:25,090 --> 01:12:27,099
机运行MapReduce的同一
machines and run MapReduce on the same

1573
01:12:27,099 --> 01:12:29,530
1000台机器，然后在
thousand machines and then when the

1574
01:12:29,530 --> 01:12:33,429
师傅被分裂了地图和工作
master was splitting up the map work and

1575
01:12:33,429 --> 01:12:34,630
排序的养殖出来不同
sort of farming it out to different

1576
01:12:34,630 --> 01:12:39,390
工人将巧妙地当它是
workers it would cleverly when it was

1577
01:12:39,390 --> 01:12:41,550
即将运行正想地图
about to run the map that was going to

1578
01:12:41,550 --> 01:12:44,640
从输入文件中读取一个将图
read from input file one it would figure

1579
01:12:44,640 --> 01:12:47,790
从出GFS的服务器实际持有
out from GFS which server actually holds

1580
01:12:47,790 --> 01:12:50,340
它的本地磁盘，并将其输入一个文件
input file one on its local disk and it

1581
01:12:50,340 --> 01:12:53,070
会送地图为输入文件
would send the map for that input file

1582
01:12:53,070 --> 01:12:55,710
在同一个MapReduce的软件
to the MapReduce software on the same

1583
01:12:55,710 --> 01:12:59,190
机，以便在默认情况下这个箭头
machine so that by default this arrow

1584
01:12:59,190 --> 01:13:01,980
从竟是当地的本地读
was actually local local read from the

1585
01:13:01,980 --> 01:13:03,450
本地磁盘并没有涉及
local disk and did not involve the

1586
01:13:03,450 --> 01:13:05,160
网络，你知道这取决于
network and you know depending on

1587
01:13:05,160 --> 01:13:07,290
故障或负载或什么是
failures or load or whatever that

1588
01:13:07,290 --> 01:13:10,020
不能总是这样做，但几乎所有的
couldn't always do that but almost all

1589
01:13:10,020 --> 01:13:11,970
地图上会非常相同的运行
the maps would be run on the very same

1590
01:13:11,970 --> 01:13:13,620
机和存储从而节约了数据
machine and stored the data thus saving

1591
01:13:13,620 --> 01:13:17,400
他们大量的时间，他们将
them vast amount of time that they would

1592
01:13:17,400 --> 01:13:19,020
否则必须等待移动输入
otherwise had to wait to move the input

1593
01:13:19,020 --> 01:13:22,770
通过网络下招数据
data across the network the next trick

1594
01:13:22,770 --> 01:13:26,250
他们打出的是，地图正如我所说
they played is that map as I mentioned

1595
01:13:26,250 --> 01:13:28,470
前门店对当地这个输出
before stores this output on the local

1596
01:13:28,470 --> 01:13:29,940
本机的磁盘，你跑地图
disk of the machine that you run the map

1597
01:13:29,940 --> 01:13:31,860
上，从而再次存储的输出
on so again storing the output of the

1598
01:13:31,860 --> 01:13:33,270
地图不需要网络
map does not require network

1599
01:13:33,270 --> 01:13:35,480
通信他马上不
communication he's not immediately

1600
01:13:35,480 --> 01:13:38,000
因为输出存储在盘
because the output stored in the disk

1601
01:13:38,000 --> 01:13:42,360
但是我们确实知道这种或那种方式
however we know for sure that one way or

1602
01:13:42,360 --> 01:13:45,060
另一个以组在一起的所有
another in order to group together all

1603
01:13:45,060 --> 01:13:46,980
你知道的方式MapReduce的是
of you know by the way the MapReduce is

1604
01:13:46,980 --> 01:13:49,650
为了定义为组在一起的所有
defined in order to group together all

1605
01:13:49,650 --> 01:13:51,510
与给定的相关联的值的
of the values associated with the given

1606
01:13:51,510 --> 01:13:55,260
关键并将它们传递到一个调用
key and pass them to a single invocation

1607
01:13:55,260 --> 01:13:57,750
生产一些机器上这是怎么回事
to produce on some machine this is going

1608
01:13:57,750 --> 01:13:59,940
要求网络通信我们
to require network communication we're

1609
01:13:59,940 --> 01:14:02,190
要你知道，我们要需要获取
gonna you know we want to need to fetch

1610
01:14:02,190 --> 01:14:03,840
所有托架，并给他们一个单
all bays and give them a single

1611
01:14:03,840 --> 01:14:05,970
机器有跨越移动
machine that have to be moved across the

1612
01:14:05,970 --> 01:14:08,670
网络，因此这本洗牌
network and so this shuffle this

1613
01:14:08,670 --> 01:14:11,690
键的移动距离是怎么样的
movement of the keys from is kind of

1614
01:14:11,690 --> 01:14:14,850
最初由行和在同一存储
originally stored by row and on the same

1615
01:14:14,850 --> 01:14:16,740
机器跑，我们需要他们的地图
machine that ran the map we need them

1616
01:14:16,740 --> 01:14:18,780
本质上通过柱上被存储在
essentially to be stored on by column on

1617
01:14:18,780 --> 01:14:19,800
那将是机器
the machine that's going to be

1618
01:14:19,800 --> 01:14:22,020
负责减少这种
responsible for reduce this

1619
01:14:22,020 --> 01:14:23,610
行内存储的改造
transformation of row storage

1620
01:14:23,610 --> 01:14:25,440
实质上列存储被称为
essentially column storage is called the

1621
01:14:25,440 --> 01:14:28,530
文件呼吁洗牌，它确实是
paper calls a shuffle and it really that

1622
01:14:28,530 --> 01:14:30,480
移动所需的每一块的数据的
required moving every piece of data

1623
01:14:30,480 --> 01:14:33,000
对面的映射网络
across the network from the map that

1624
01:14:33,000 --> 01:14:34,470
它产生的减少会
produced it to the reduce that would

1625
01:14:34,470 --> 01:14:36,300
需要它，现在它就像昂贵的
need it and now it's like the expensive

1626
01:14:36,300 --> 01:14:41,870
MapReduce的一部分呀
part of the MapReduce yeah

1627
01:14:51,840 --> 01:14:53,860
你说得对，你能想象一个不同
you're right you can imagine a different

1628
01:14:53,860 --> 01:14:55,239
定义中，你有一个更亲切
definition in which you have a more kind

1629
01:14:55,239 --> 01:14:57,989
流的减少，我不知道我
of streaming reduce I don't know I

1630
01:14:57,989 --> 01:15:00,070
没有经过我认为这不
haven't thought this through I don't

1631
01:15:00,070 --> 01:15:02,050
知道为什么这是否是可行的
know why whether that would be feasible

1632
01:15:02,050 --> 01:15:04,239
或不肯定，只要程序员
or not certainly as far as programmer

1633
01:15:04,239 --> 01:15:06,070
接口一样，如果目标的
interface like if the goal their

1634
01:15:06,070 --> 01:15:09,940
头号目标真的能够
number-one goal really was to be able to

1635
01:15:09,940 --> 01:15:11,980
人们可以很容易地计划谁
make it easy to program by people who

1636
01:15:11,980 --> 01:15:13,989
只是没有在发生了什么事的想法
just had no idea of what was going on in

1637
01:15:13,989 --> 01:15:16,660
该系统因此它可能是你知道
the system so it may be that you know

1638
01:15:16,660 --> 01:15:18,460
这种斑点，这是真正的方式减少
this speck this is really the way reduce

1639
01:15:18,460 --> 01:15:22,660
功能看，你知道在C ++或
functions look and you know in C++ or

1640
01:15:22,660 --> 01:15:24,850
类似的流媒体版本
something like a streaming version of

1641
01:15:24,850 --> 01:15:28,090
这是现在开始看我不
this is now starting to look I don't

1642
01:15:28,090 --> 01:15:30,190
知道它是如何看可能不是这样
know how it look probably not this

1643
01:15:30,190 --> 01:15:33,250
符号，但你也许知道这可能是
symbol but you know maybe it could be

1644
01:15:33,250 --> 01:15:35,320
这样做的方式，事实上许多现代
done that way and indeed many modern

1645
01:15:35,320 --> 01:15:37,960
系统的人得到了很多更
systems people got a lot more

1646
01:15:37,960 --> 01:15:41,530
复杂与现代的东西，
sophisticated with modern things that

1647
01:15:41,530 --> 01:15:43,420
是接班人的MapReduce和
are the successors the MapReduce and

1648
01:15:43,420 --> 01:15:45,430
他们确实涉及处理
they do indeed involve processing

1649
01:15:45,430 --> 01:15:48,640
数据流往往不是这样
streams of data often rather than this

1650
01:15:48,640 --> 01:15:50,739
很分批进场有一批
very batch approach there is a batch

1651
01:15:50,739 --> 01:15:52,780
在这个意义上接近，我们等到
approach in the sense that we wait until

1652
01:15:52,780 --> 01:15:54,970
我们得到的所有数据，然后我们处理
we get all the data and then we process

1653
01:15:54,970 --> 01:15:57,250
它所以首先你接下来要
it so first of all that you then have to

1654
01:15:57,250 --> 01:15:59,670
具有有限的输入权的概念
have a notion of finite inputs right

1655
01:15:59,670 --> 01:16:02,170
现代系统经常做你的确
modern systems often do indeed you

1656
01:16:02,170 --> 01:16:05,980
流和并能够利用
streams and and are able to take

1657
01:16:05,980 --> 01:16:08,910
优势一些效率的做
advantage of some efficiencies do that

1658
01:16:08,910 --> 01:16:15,460
MapReduce的好了，所以这是在点
MapReduce okay so this is the point at

1659
01:16:15,460 --> 01:16:17,380
此洗牌是所有
which this shuffle is where all the

1660
01:16:17,380 --> 01:16:19,450
网络流量会发生这可以
network traffic happens this can

1661
01:16:19,450 --> 01:16:21,040
实际上是数据的大量所以如果
actually be a vast amount of data so if

1662
01:16:21,040 --> 01:16:23,920
你想想那种如果你选
you think about sort if you're sorting

1663
01:16:23,920 --> 01:16:26,710
排序的输出具有相同
the the output of the sort has the same

1664
01:16:26,710 --> 01:16:29,440
大小输入到排序，以便
size as the input to the sort so that

1665
01:16:29,440 --> 01:16:30,850
这意味着，如果你是，你知道，如果你的
means that if you're you know if your

1666
01:16:30,850 --> 01:16:32,890
输入数据的10个TB的你
input is 10 terabytes of data and you're

1667
01:16:32,890 --> 01:16:34,750
运行你移动10排序
running a sort you're moving 10

1668
01:16:34,750 --> 01:16:36,220
通过网络在万亿字节的数据
terabytes of data across a network at

1669
01:16:36,220 --> 01:16:38,410
这点和你的输出也将是
this point and your output will also be

1670
01:16:38,410 --> 01:16:40,780
10个TB的，因此这是相当多
10 terabytes and so this is quite a lot

1671
01:16:40,780 --> 01:16:42,430
数据，然后它的确是从任何
of data and then indeed it is from any

1672
01:16:42,430 --> 01:16:44,140
MapReduce作业虽然不是所有有
MapReduce jobs although not all there's

1673
01:16:44,140 --> 01:16:46,450
一些显著减少
some that significantly reduce the

1674
01:16:46,450 --> 01:16:49,690
在这些阶段某人的数据量
amount of data at these stages somebody

1675
01:16:49,690 --> 01:16:51,070
提到哦，如果你想进什么
mentioned Oh what if you want to feed

1676
01:16:51,070 --> 01:16:52,900
减少输出到另一个
the output of reduce into another

1677
01:16:52,900 --> 01:16:55,150
MapReduce工作，事实上，这是常
MapReduce job and indeed that was often

1678
01:16:55,150 --> 01:16:56,979
什么人想做的事和
what people wanted to do and

1679
01:16:56,979 --> 01:16:58,389
在案件的输出减少威力
in case the output of the reduce might

1680
01:16:58,389 --> 01:17:00,400
是巨大的像四个排序或网页和
be enormous like four sort or web and

1681
01:17:00,400 --> 01:17:03,400
混合输出的上十产生
mixing the output of the produces on ten

1682
01:17:03,400 --> 01:17:05,260
输入的兆兆字节的输出
terabytes of input the output of the

1683
01:17:05,260 --> 01:17:07,719
再次降低了要去有十数TB等等
reduces again gonna be ten terabytes so

1684
01:17:07,719 --> 01:17:09,249
的减小输出也被存储
the output of the reduce is also stored

1685
01:17:09,249 --> 01:17:12,639
在GFS和系统，你会知道
on GFS and the system would you know

1686
01:17:12,639 --> 01:17:13,869
减少只会产生这些关键
reduce would just produce these key

1687
01:17:13,869 --> 01:17:18,369
值对但MapReduce框架
value pairs but the MapReduce framework

1688
01:17:18,369 --> 01:17:20,320
将收集起来，并写入到
would gather them up and write them into

1689
01:17:20,320 --> 01:17:23,679
在GFS等有巨大的文件
giant files on GFS and so there was

1690
01:17:23,679 --> 01:17:27,489
另一轮网络通信的
another round of network communication

1691
01:17:27,489 --> 01:17:30,219
让每个输出所需
required to get the output of each

1692
01:17:30,219 --> 01:17:33,039
减少对GFS服务器需要
reduce to the GFS server that needed to

1693
01:17:33,039 --> 01:17:35,229
存储减少和，因为你可能
store that reduce and because you might

1694
01:17:35,229 --> 01:17:37,959
认为他们可以发挥的
think that they could have played the

1695
01:17:37,959 --> 01:17:39,639
同一特技与存储的输出
same trick with the output of storing

1696
01:17:39,639 --> 01:17:42,489
政府飞行服务队的服务器，从而使输出
the output on the GFS server that

1697
01:17:42,489 --> 01:17:46,449
碰巧运行MapReduce的工作人员
happened to run the MapReduce worker

1698
01:17:46,449 --> 01:17:48,969
跑的减少，也许他们做
that ran the reduce and maybe they did

1699
01:17:48,969 --> 01:17:51,760
这样做，但因为GFS以及
do that but because GFS as well as

1700
01:17:51,760 --> 01:17:53,979
性能也分割数据
splitting data for performance also

1701
01:17:53,979 --> 01:17:55,929
保持两个或三个副本故障
keeps two or three copies for fault

1702
01:17:55,929 --> 01:17:58,030
宽容是手段，不管你是什么
tolerance that means no matter what you

1703
01:17:58,030 --> 01:17:59,079
需要写入数据的一个副本
need to write one copy of the data

1704
01:17:59,079 --> 01:18:01,349
通过网络到另一台服务器
across a network to a different server

1705
01:18:01,349 --> 01:18:03,070
所以有很多网络
so there's a lot of network

1706
01:18:03,070 --> 01:18:05,699
这里的沟通和这里还一堆
communication here and a bunch here also

1707
01:18:05,699 --> 01:18:08,199
我是这样的网络通信
and I was this network communication

1708
01:18:08,199 --> 01:18:09,999
真正限制了吞吐量
that really limited the throughput in

1709
01:18:09,999 --> 01:18:10,659
MapReduce的
MapReduce

1710
01:18:10,659 --> 01:18:17,679
在2004年到2020年，因为这网络
in 2004 in 2020 because this network

1711
01:18:17,679 --> 01:18:19,869
安排是这样一个限制因素
arrangement was such a limiting factor

1712
01:18:19,869 --> 01:18:21,789
这么多东西的人想做的事
for so many things people wanted to do

1713
01:18:21,789 --> 01:18:23,920
在数据中心的现代数据中心
in datacenters modern data center

1714
01:18:23,920 --> 01:18:26,079
网络有很多在根快
networks are a lot faster at the root

1715
01:18:26,079 --> 01:18:28,959
莫过于此了，所以你知道一个
than this was and so you know one

1716
01:18:28,959 --> 01:18:30,639
典型的数据中心网络你可能
typical data center network you might

1717
01:18:30,639 --> 01:18:32,889
今天看到其实有很多根，而不是
see today actually has many root instead

1718
01:18:32,889 --> 01:18:34,329
单根的切换一切
of a single root switch that everything

1719
01:18:34,329 --> 01:18:37,630
要经过你可能有你
has to go through you might have you

1720
01:18:37,630 --> 01:18:40,269
知道许多根交换机和每个机架
know many root switches and each rack

1721
01:18:40,269 --> 01:18:42,459
开关具有到每个这些连接
switch has a connection to each of these

1722
01:18:42,459 --> 01:18:44,530
排序复制根的开关和
sort of replicated root switches and the

1723
01:18:44,530 --> 01:18:46,479
流量是根之间分裂
traffic is split up among the root

1724
01:18:46,479 --> 01:18:48,599
切换所以现代数据中心网络
switches so modern data center networks

1725
01:18:48,599 --> 01:18:52,269
有吞吐量远远更多的网络和
have far more network throughput and

1726
01:18:52,269 --> 01:18:54,880
因为，实际上现代，我认为
because of that actually modern I think

1727
01:18:54,880 --> 01:18:57,099
谷歌MapReduce的使用排序的停止
Google sort of stopped using MapReduce a

1728
01:18:57,099 --> 01:19:00,309
几年前，但他们停止前
few years ago but before they stopped

1729
01:19:00,309 --> 01:19:02,590
使用它的现代MapReduce的实际
using it the modern MapReduce actually

1730
01:19:02,590 --> 01:19:04,959
不再试图运行的地图
no longer tried to run the maps on the

1731
01:19:04,959 --> 01:19:06,939
同一台计算机上存储的他们的数据
same machine as the data stored on they

1732
01:19:06,939 --> 01:19:08,139
很高兴从投票数据
were happy to vote the data from

1733
01:19:08,139 --> 01:19:11,369
任何地方，因为他们只是假设
anywhere because they just assumed that

1734
01:19:11,369 --> 01:19:16,439
是非常快好我们的出
was extremely fast okay we're out of

1735
01:19:16,439 --> 01:19:18,439
时间的MapReduce
time for MapReduce

1736
01:19:18,439 --> 01:19:21,689
我们有一个实验室在由于下个月底
we have a lab due at the end of next

1737
01:19:21,689 --> 01:19:22,349
周
week

1738
01:19:22,349 --> 01:19:24,840
在其中，你会有些写自己
in which you'll write your own somewhat

1739
01:19:24,840 --> 01:19:27,899
简化的MapReduce这么有乐趣
simplified MapReduce so have fun with

1740
01:19:27,899 --> 01:19:28,349
那
that

1741
01:19:28,349 --> 01:19:33,079
看到你在星期四
and see you on Thursday

