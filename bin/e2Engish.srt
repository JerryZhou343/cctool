1
00:00:02,500 --> 00:00:07,370
today I'd like to talk about GO which

2
00:00:07,370 --> 00:00:08,990
is interesting especially interesting

3
00:00:08,990 --> 00:00:10,849
for us in this course because course GO

4
00:00:10,849 --> 00:00:12,709
is the language at the labs you're all

5
00:00:12,709 --> 00:00:14,450
going to do the labs in and so I want to

6
00:00:14,450 --> 00:00:17,090
focus today particularly on some of the

7
00:00:17,090 --> 00:00:19,280
machinery that sort of most useful in

8
00:00:19,280 --> 00:00:22,940
the labs and in most particular to

9
00:00:22,940 --> 00:00:26,170
distributed programming um first of all

10
00:00:26,170 --> 00:00:29,600
you know it's worth asking why we use go

11
00:00:29,600 --> 00:00:32,180
in this class in fact we could have used

12
00:00:32,180 --> 00:00:33,890
any one of a number of other system

13
00:00:33,890 --> 00:00:35,899
style languages plenty languages like

14
00:00:35,899 --> 00:00:38,210
Java or C sharp or even Python that

15
00:00:38,210 --> 00:00:40,730
provide the kind of facilities we need

16
00:00:40,730 --> 00:00:42,859
and indeed we used to use C++ in this

17
00:00:42,859 --> 00:00:47,079
class and it worked out fine it'll go

18
00:00:47,079 --> 00:00:49,010
indeed like many other languages

19
00:00:49,010 --> 00:00:50,719
provides a bunch of features which are

20
00:00:50,719 --> 00:00:51,649
particularly convenient

21
00:00:51,649 --> 00:00:53,409
that's good support for threads and

22
00:00:53,409 --> 00:00:56,659
locking and synchronization between

23
00:00:56,659 --> 00:00:59,239
threads which we use a lot it is a

24
00:00:59,239 --> 00:01:01,789
convenient remote procedure call package

25
00:01:01,789 --> 00:01:04,879
which doesn't sound like much but it

26
00:01:04,879 --> 00:01:06,380
actually turns out to be a significant

27
00:01:06,380 --> 00:01:09,950
constraint from in languages like C++

28
00:01:09,950 --> 00:01:11,210
for example it's actually a bit hard to

29
00:01:11,210 --> 00:01:13,579
find a convenient easy to use remote

30
00:01:13,579 --> 00:01:14,930
procedure call package and of course we

31
00:01:14,930 --> 00:01:16,570
use it all the time in this course or

32
00:01:16,570 --> 00:01:18,409
programs and different machines to talk

33
00:01:18,409 --> 00:01:22,610
to each other unlike C++ go is type safe

34
00:01:22,610 --> 00:01:25,100
and memory safe that is it's pretty hard

35
00:01:25,100 --> 00:01:27,619
to write a program that due to a bug

36
00:01:27,619 --> 00:01:29,180
scribbles over some random piece of

37
00:01:29,180 --> 00:01:31,340
memory and then causes the program to do

38
00:01:31,340 --> 00:01:34,789
mysterious things and that just

39
00:01:34,789 --> 00:01:36,320
eliminates a big class of bugs similarly

40
00:01:36,320 --> 00:01:39,680
it's garbage collected which means you

41
00:01:39,680 --> 00:01:41,869
never in danger of priam the same memory

42
00:01:41,869 --> 00:01:44,509
twice or free memory that's still in use

43
00:01:44,509 --> 00:01:46,340
or something the garbage vector just

44
00:01:46,340 --> 00:01:48,859
frees things when they stop being used

45
00:01:48,859 --> 00:01:51,920
and one thing it's maybe not obvious

46
00:01:51,920 --> 00:01:54,829
until you played around with just this

47
00:01:54,829 --> 00:01:56,719
kind of programming before but the

48
00:01:56,719 --> 00:01:58,640
combination of threads and garbage

49
00:01:58,640 --> 00:02:01,880
collection is particularly important one

50
00:02:01,880 --> 00:02:03,200
of the things that goes wrong in a non

51
00:02:03,200 --> 00:02:06,109
garbage collected language like C++ if

52
00:02:06,109 --> 00:02:08,899
you use threads is that it's always a

53
00:02:08,899 --> 00:02:10,690
bit of a puzzle and requires a bunch of

54
00:02:10,690 --> 00:02:13,430
bookkeeping to figure out when the last

55
00:02:13,430 --> 00:02:14,190
thread

56
00:02:14,190 --> 00:02:15,660
that's using a shared object has

57
00:02:15,660 --> 00:02:17,340
finished using that object because only

58
00:02:17,340 --> 00:02:19,530
then can you free the object as you end

59
00:02:19,530 --> 00:02:20,910
up writing quite a bit of coat it's like

60
00:02:20,910 --> 00:02:22,620
manually the programmer it's about a

61
00:02:22,620 --> 00:02:24,480
bunch of code to manually you know do

62
00:02:24,480 --> 00:02:26,580
reference counting or something in order

63
00:02:26,580 --> 00:02:28,470
to figure out you know when the last

64
00:02:28,470 --> 00:02:30,030
thread stopped using an object and

65
00:02:30,030 --> 00:02:32,460
that's just a pain and that problem

66
00:02:32,460 --> 00:02:34,710
completely goes away if you use garbage

67
00:02:34,710 --> 00:02:36,560
collection like we haven't go

68
00:02:36,560 --> 00:02:39,390
and finally the language is simple much

69
00:02:39,390 --> 00:02:41,460
simpler than C++ one of the problems

70
00:02:41,460 --> 00:02:44,640
with using C++ is that often if you made

71
00:02:44,640 --> 00:02:47,250
an error you know maybe even just a typo

72
00:02:47,250 --> 00:02:51,420
the the error message you get back from

73
00:02:51,420 --> 00:02:53,730
the compiler is so complicated that in

74
00:02:53,730 --> 00:02:56,160
C++ it's usually not worth trying to

75
00:02:56,160 --> 00:02:57,510
figure out what the error message meant

76
00:02:57,510 --> 00:02:59,520
and I find it's always just much quicker

77
00:02:59,520 --> 00:03:01,470
to go look at the line number and try to

78
00:03:01,470 --> 00:03:02,670
guess what the error must have been

79
00:03:02,670 --> 00:03:04,170
because the language is far too

80
00:03:04,170 --> 00:03:04,800
complicated

81
00:03:04,800 --> 00:03:07,140
whereas go is you know probably doesn't

82
00:03:07,140 --> 00:03:09,710
have a lot of people's favorite features

83
00:03:09,710 --> 00:03:11,580
but it's relatively straightforward

84
00:03:11,580 --> 00:03:14,940
language okay so at this point you're

85
00:03:14,940 --> 00:03:17,250
both on the tutorial if you're looking

86
00:03:17,250 --> 00:03:19,290
for sort of you know what to look at

87
00:03:19,290 --> 00:03:21,630
next to learn about the language a good

88
00:03:21,630 --> 00:03:23,190
place to look is the document titled

89
00:03:23,190 --> 00:03:25,590
effective go which you know you can find

90
00:03:25,590 --> 00:03:30,390
by searching the web all right the first

91
00:03:30,390 --> 00:03:33,110
thing I want to talk about is threads

92
00:03:33,110 --> 00:03:35,940
the reason why we care a lot about

93
00:03:35,940 --> 00:03:39,000
threads in this course is that threads

94
00:03:39,000 --> 00:03:41,459
are the sort of main tool we're going to

95
00:03:41,459 --> 00:03:44,370
be using to manage concurrency in

96
00:03:44,370 --> 00:03:47,340
programs and concurrency is a particular

97
00:03:47,340 --> 00:03:49,920
interest in distributed programming

98
00:03:49,920 --> 00:03:52,440
because it's often the case that one

99
00:03:52,440 --> 00:03:53,820
program actually needs to talk to a

100
00:03:53,820 --> 00:03:55,890
bunch of other computers you know client

101
00:03:55,890 --> 00:03:58,230
may talk to many servers or a server may

102
00:03:58,230 --> 00:04:00,300
be serving requests at the same time on

103
00:04:00,300 --> 00:04:02,430
behalf of many different clients and so

104
00:04:02,430 --> 00:04:04,830
we need a way to say oh you know I'm my

105
00:04:04,830 --> 00:04:06,030
program really has seven different

106
00:04:06,030 --> 00:04:07,410
things going on because it's talking to

107
00:04:07,410 --> 00:04:10,110
seven different clients and I want a

108
00:04:10,110 --> 00:04:12,450
simple way to allow it to do these seven

109
00:04:12,450 --> 00:04:14,459
different things you know without too

110
00:04:14,459 --> 00:04:16,858
much complex programming I mean sort of

111
00:04:16,858 --> 00:04:19,589
thrust threads are the answer so these

112
00:04:19,589 --> 00:04:21,630
are the things that the go documentation

113
00:04:21,630 --> 00:04:24,419
calls go routines which I call threads

114
00:04:24,419 --> 00:04:26,789
they're go routines are really this same

115
00:04:26,789 --> 00:04:27,880
as what everybody else calls

116
00:04:27,880 --> 00:04:32,560
Red's so the way to think of threads is

117
00:04:32,560 --> 00:04:36,600
that you have a program of one program

118
00:04:36,600 --> 00:04:43,120
and one address space I'm gonna draw a

119
00:04:43,120 --> 00:04:46,060
box to sort of denote an address space

120
00:04:46,060 --> 00:04:48,250
and within that address space in a

121
00:04:48,250 --> 00:04:51,520
serial program without threads you just

122
00:04:51,520 --> 00:04:54,550
have one thread of execution executing

123
00:04:54,550 --> 00:04:57,040
code in that address space one program

124
00:04:57,040 --> 00:05:00,100
counter one set of registers one stack

125
00:05:00,100 --> 00:05:02,080
that are sort of describing the current

126
00:05:02,080 --> 00:05:04,180
state of the execution in a threaded

